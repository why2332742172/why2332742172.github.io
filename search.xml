<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>JAVA作业：数组模拟栈和酒店管理系统的模拟</title>
    <url>/2020/08/12/JAVA%E4%BD%9C%E4%B8%9A%EF%BC%9A%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88%E5%92%8C%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>JAVA作业：数组模拟栈和酒店管理系统的模拟</p>
<a id="more"></a>



<hr>
<h1 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h1><blockquote>
<p>题目要求：</p>
<blockquote>
<p>编写程序，使用一维数组，模拟栈数据结构。<br>1、这个栈可以存储java中的任何引用类型的数据。<br>2、在栈中提供push方法模拟压栈。（栈满了，要有提示信息。）<br>3、在栈中提供pop方法模拟弹栈。（栈空了，也有有提示信息。）<br>4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作。</p>
</blockquote>
</blockquote>
<p>首先是我的想法和思路：</p>
<blockquote>
<p>既然是模拟栈，那么就要做到先进后出的功能。栈如何去定位当前元素呢？<br>通过栈帧index。<br>所以我需要一个index变量去定位每次栈顶的位置，从而去判断栈是否满了<br>而且还可以在对数组下标为index的变量操作时达到“先进后出”的目的<br>接着就是题目中要求的“这个栈可以存储java中的任何引用类型的数据。”<br>意味着我们这个数组要用的是Obeject类型。<br>至此大体已出</p>
</blockquote>
<p>接下来是我的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先就是MyStack类，这个类是关于栈的模拟</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(Object[] elements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(index != elements.length - <span class="number">1</span>)&#123;</span><br><span class="line">    		index++;</span><br><span class="line">    		elements[index] = object;</span><br><span class="line">    		System.out.println(<span class="string">&quot;压栈成功&quot;</span>);</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;错误：栈满！无法压栈！&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是关于测试程序了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">测试程序MyStackTest</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入栈的大小：&quot;</span>);</span><br><span class="line">        length = input.nextInt(); </span><br><span class="line">        String[] a1 = <span class="keyword">new</span> String[length];</span><br><span class="line">        MyStack myStack1 = <span class="keyword">new</span> MyStack(a1);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">3</span>)&#123;</span><br><span class="line">        	    System.out.println(<span class="string">&quot;请输入您要进行的操作：1代表push（压栈），2代表pop（弹栈）,3表示停止该操作&quot;</span>);</span><br><span class="line">        	    flag = input.nextInt();</span><br><span class="line">        	    <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">        	    	String toInPut;</span><br><span class="line">        	    	System.out.println(<span class="string">&quot;请输入您要压入栈的内容&quot;</span>);</span><br><span class="line">        	    	toInPut = input.next();</span><br><span class="line">        	    	myStack1.push(toInPut);        	  </span><br><span class="line">        	     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">        	     	myStack1.pop();</span><br><span class="line">        	     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">3</span>)&#123;</span><br><span class="line">        	     	<span class="keyword">break</span>;</span><br><span class="line">        	     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	        System.out.println(<span class="string">&quot;输入不合法！请输入您要进行的操作：1代表push（压栈），2代表pop（弹栈），3表示停止该操作&quot;</span>);	    </span><br><span class="line">        	     &#125;</span><br><span class="line">        	   &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure>
<p>这就是数组模拟栈。</p>
<hr>
<h1 id="酒店管理系统的模拟"><a href="#酒店管理系统的模拟" class="headerlink" title="酒店管理系统的模拟"></a>酒店管理系统的模拟</h1><blockquote>
<p>题目要求</p>
<blockquote>
<p>为某个酒店编写程序：酒店管理系统，模拟订房、退房、打印所有房间状态等功能。<br>1、该系统的用户是：酒店前台。<br>2、酒店使用一个二维数组来模拟。“Room[][] rooms;”<br>3、酒店中的每一个房间应该是一个java对象：Room<br>4、每一个房间Room应该有：房间编号、房间类型、房间是否空闲.<br>5、系统应该对外提供的功能：</p>
<blockquote>
<p>可以预定房间：用户输入房间编号，订房。<br>可以退房：用户输入房间编号，退房。<br>可以查看房间的状态：用户输入某个指令应该可以查看所有房间状态。</p>
</blockquote>
</blockquote>
</blockquote>
<p>想法和思路：</p>
<blockquote>
<p>该题目较为简单，主要思想就是去实现每个功能<br>题目已经给了要求：用一个Room类和二维数组去实现。<br>Room类主要是存储每个房间的信息：例如门牌号，是否空闲等<br>而二维数组则是去存储每个房间。<br>接下来只需实现即可</p>
</blockquote>
<p>我的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先是实现各个功能以及Room类</span><br><span class="line">注意，这里最好是吧Room类和功能实现分开写，但是我合并了，以后不要这样</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Room[][] rooms = <span class="keyword">new</span> Room[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> roomId;</span><br><span class="line">    <span class="keyword">int</span> floor =<span class="number">0</span>,number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    String roomStyle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialization</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k,p;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>;k &lt; <span class="number">3</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(p = <span class="number">0</span>;p &lt; <span class="number">10</span>;p++)&#123;</span><br><span class="line">                rooms[k][p] = <span class="keyword">new</span> Room();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoomId</span><span class="params">(<span class="keyword">int</span> roomId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roomId = roomId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reserveRoomId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        floor = (roomId/<span class="number">100</span>) - <span class="number">1</span>;</span><br><span class="line">        number = (roomId%<span class="number">100</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderRoom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rooms[floor][number].flag == <span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该房间已满！请另换一间！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rooms[floor][number].flag = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;预订成功！您预订的房间号为：&quot;</span> + roomId + <span class="string">&quot;房间位于第&quot;</span> + (floor+<span class="number">1</span>) + <span class="string">&quot;层0&quot;</span> + (number+<span class="number">1</span>) + <span class="string">&quot;号房&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Check_out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rooms[floor][number].flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该房间本就为空！无法退房！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rooms[floor][number].flag = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;退房成功！&quot;</span> + roomId + <span class="string">&quot;房间已成功退房&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">View_information</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将为您打印全部房间信息：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i,j,roomids;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号\t\t房间是否满员\t\t房间类型&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">10</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    rooms[i][j].roomStyle = <span class="string">&quot;普通房&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                    rooms[i][j].roomStyle = <span class="string">&quot;豪华房&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    rooms[i][j].roomStyle = <span class="string">&quot;贵宾房&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                roomids = ((i+<span class="number">1</span>)*<span class="number">100</span>)+(j+<span class="number">1</span>);</span><br><span class="line">                System.out.println(roomids + <span class="string">&quot;\t\t\t&quot;</span> + rooms[i][j].flag + <span class="string">&quot;\t\t\t&quot;</span> + rooms[i][j].roomStyle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure>

<p>接下来就是测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写到测试程序我就意识到得注意程序的用户交互性</span><br><span class="line">用户可能会有各种输入，那么正确的输入我们得去执行功能</span><br><span class="line">而错误的输入我们则得去提醒用户输入错误以及正确的输入方式</span><br><span class="line">这样可以避免很多麻烦</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> roomId;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Room.Initialization();</span><br><span class="line">        Room room = <span class="keyword">new</span> Room();</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎来到why牌酒店管理系统！~&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;本酒店一共有3层楼，每层楼10间房间&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;下面请输入：1（预订房间）；2（退房）；3（查看所有房间信息）；4（退出系统）&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">4</span>)&#123;</span><br><span class="line">            flag = input.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;现在是订房界面：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入房间号：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;注意：房间号每层尾号从1开始到9结束，例如1层3号房就是：103&quot;</span>);</span><br><span class="line">                roomId = input.nextInt();</span><br><span class="line">                <span class="keyword">if</span>(((roomId/<span class="number">100</span>) &gt;= <span class="number">1</span> &amp;&amp;(roomId/<span class="number">100</span>) &lt;=<span class="number">3</span>)&amp;&amp;((roomId%<span class="number">100</span>) &gt;=<span class="number">1</span>&amp;&amp;(roomId%<span class="number">100</span>) &lt;=<span class="number">10</span>))&#123;</span><br><span class="line">                    room.setRoomId(roomId);</span><br><span class="line">                    room.reserveRoomId();</span><br><span class="line">                    room.orderRoom();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入房间号错误！注意：房间号每层尾号从1开始到9结束，例如1层3号房就是：103&quot;</span>);</span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;现在是退房界面：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入房间号：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;注意：房间号每层尾号从1开始到9结束，例如1层3号房就是：103&quot;</span>);</span><br><span class="line">                roomId = input.nextInt();</span><br><span class="line">                <span class="keyword">if</span>(((roomId/<span class="number">100</span>) &gt;= <span class="number">1</span> &amp;&amp;(roomId/<span class="number">100</span>) &lt;=<span class="number">3</span>)&amp;&amp;((roomId%<span class="number">100</span>) &gt;=<span class="number">1</span>&amp;&amp;(roomId%<span class="number">100</span>) &lt;=<span class="number">10</span>))&#123;</span><br><span class="line">                    room.setRoomId(roomId);</span><br><span class="line">                    room.reserveRoomId();</span><br><span class="line">                    room.Check_out();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入房间号错误！注意：房间号每层尾号从1开始到9结束，例如1层3号房就是：103&quot;</span>);</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">3</span>)&#123;</span><br><span class="line">                room.View_information();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">4</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;感谢使用why牌酒店管理系统！已关机！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入错误！请输入：1（预订房间）；2（退房）；3（查看所有房间信息）；4（退出系统）&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                               </span><br></pre></td></tr></table></figure>

<p>入上便是我的程序，功能实现完全没问题，那么是不是就没问题了呢？<br><strong>并不是。</strong></p>
<hr>
<h1 id="我的程序的问题"><a href="#我的程序的问题" class="headerlink" title="我的程序的问题"></a>我的程序的问题</h1><p>在对比了老师写的程序后，我发现了我现在的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">虽然会封装，知道要重写方法（例如toString,equal方法）但是不会去用。</span><br><span class="line">在老师的程序中，强调了无论如何，那怕用不上也要对程序封装</span><br><span class="line">然后提供set和get方法，这点是我以后必须得记住的。</span><br></pre></td></tr></table></figure>

<p>至于老师的代码不予提供，自行寻找。</p>
<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记-1</title>
    <url>/2020/07/30/java_study_1/</url>
    <content><![CDATA[<p>梦开始的地方？</p>
<a id="more"></a>

<hr>
<h2 id="字符连接符号"><a href="#字符连接符号" class="headerlink" title="字符连接符号 +"></a>字符连接符号 +</h2><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;why&quot;</span></span><br><span class="line">String b = <span class="string">&quot;cy&quot;</span></span><br></pre></td></tr></table></figure>

<p>想要输出”whycy”，则写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(a+b);</span><br></pre></td></tr></table></figure>

<p>不同于C之处是：不用去纠结转化符的东西，只要“+”就完事！<br>也发现两个字符串的拼接也是如此<br>String c = a+b 那么 c 就是”whycy”</p>
<p>在java中，方法是很重要的东西，个人觉得方法就是c里面的函数？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123; </span><br><span class="line"><span class="comment">//入口主方法							</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;			</span><br><span class="line">		<span class="keyword">int</span> x =<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">int</span> y = <span class="number">200</span>;</span><br><span class="line">		sumInt(x,y);</span><br><span class="line">		Test1.sumInt(x,y);</span><br><span class="line"><span class="comment">//调用方法sumInt    调用方法有两种写法，在此可分为</span></span><br><span class="line"><span class="comment">//Test1.sumInt(x,y)和sunInt(x,y)</span></span><br><span class="line"><span class="comment">//有何区别？当方法在一个大类（Test1类）之中，（也就是最外面</span></span><br><span class="line"><span class="comment">//同一个大括号里面）就可以省略类名（Test1），但是不在的话就得							</span></span><br><span class="line"><span class="comment">//加上类名来识别。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 求和方法（函数）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumInt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; 			</span><br><span class="line"> 		 <span class="keyword">int</span> z = x + y;</span><br><span class="line"> 		 System.out.println(x + <span class="string">&quot;+&quot;</span> + y + <span class="string">&quot;=&quot;</span> + z);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>在java中，方法是可以重载的，意思是<br>“功能相似”的方法，可以让“方法名相同”，通过传参的不同来区分不同的具体细化内容，更易于以后的代码编写。<br>例如，定义一个sum方法，返回两参数相加的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumInt</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sumLong</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sumDouble</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样写非常麻烦，但是完成的功能差不多，他们仅仅有微小的差异（传入和返回的数据类型不同），<br> 为什么说他麻烦？因为在调用这三个方法时，得写不同的方法名，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sumInt(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sumLong(<span class="number">10L</span>,<span class="number">2000L</span>)</span><br><span class="line">sunDouble(<span class="number">3.2</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一旦方法多了就会带来麻烦，所以现在将他们的方法名统一到一个  sum 上，就写为了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;int求和&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;long求和&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;double求和&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到，方法名字均为  sum  而且调用时不用去担心是否调用错方法，直接sum()输入啥都行！<br> 这就是方法重载的优点。</p>
<hr>
<h2 id="类的初步"><a href="#类的初步" class="headerlink" title="类的初步"></a>类的初步</h2><p>类，是一个有共同特征的”对象”的集合体，可以认为是结构体？但是个人感觉又不像，部分相同部分不同；<br>定义方法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XueSheng</span></span>&#123;  		</span><br><span class="line">					</span><br><span class="line"><span class="comment">/*为什么加public?因为如果你单独去在一个 .java 文件中写的话，</span></span><br><span class="line"><span class="comment">必须得有public的类，当然我不咋这么做。例如我如果在一个完整</span></span><br><span class="line"><span class="comment">的代码段中，那么类的定义也可以写成如下即可。*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XueSheng</span></span>&#123;</span><br><span class="line">											</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对我来说更常用的是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XueSheng</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> idNumber;</span><br><span class="line">	String name;</span><br><span class="line">	String address;</span><br><span class="line">	等等属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>类是对象的集合体，对象是类中的单个元素，对象具备类中定义的所有特征。<br>如何创建对象？用  new  运算符（没对象，new一个）<br>具体语法是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XueSheng s1 = <span class="keyword">new</span> XueSheng();</span><br></pre></td></tr></table></figure>

<p>第一个XueSheng 是变量类型<br>s1是变量名（s1被称为”引用”）<br>new是运算符<br>XueSheng()是构造方法  无构造方法则为默认的<br>通过   .    运算符去访问对象的每个属性<br>例如每个学生的学号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1.idNumber</span><br></pre></td></tr></table></figure>

<p>姓名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1.name等等</span><br></pre></td></tr></table></figure>

<p>在此基础去对每个对象进行操作</p>
<hr>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法的语法结构是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形式参数列表)&#123;</span><br><span class="line">    构造方法体;</span><br><span class="line">    通常在构造方法体当中给属性赋值，完成属性的初始化。</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>例如上面的XueSheng方法，我们就可以通过定义构造方法来完成对XueSheng中对象的初始赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XueSheng</span> <span class="params">(<span class="keyword">int</span> a,String b,String c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	idNumber = a;</span><br><span class="line">	name = b;</span><br><span class="line">	address = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样去初始化每个XueSheng中对象的属性的初始值，从而去帮助我们干一些事情。<br>当然，前面提到了默认的无参数构造方法，他的具体类容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XueSheng</span><span class="params">()</span></span>&#123;</span><br><span class="line">	idNumber = <span class="number">0</span>;</span><br><span class="line">	name = <span class="keyword">null</span>;</span><br><span class="line">	address = <span class="keyword">null</span></span><br><span class="line">	可以看到，在默认的构造方法中，数据均为<span class="number">0</span>，而其他为<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">同时，也可以通过方法重载的用法，来编写多个构造方法</span><br><span class="line">例如</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XueSheng</span><span class="params">(<span class="keyword">int</span> a,String b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	内容省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XueSheng</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">这样也是支持的，当你在构造时，使用的语法是</span><br><span class="line">XueSheng s1 = <span class="keyword">new</span> XueSheng(<span class="number">233</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">则调用第一个构造方法</span><br><span class="line">XueSheng s2 = <span class="keyword">new</span> XueSheng(<span class="number">34444</span>)</span><br><span class="line">则调用第二个构造方法</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记10-（访问控制权限/Object类）</title>
    <url>/2020/08/08/java_study_10/</url>
    <content><![CDATA[<p>访问控制权限/Object类</p>
<a id="more"></a>



<hr>
<h1 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h1><hr>
<h2 id="访问控制权限都有哪些"><a href="#访问控制权限都有哪些" class="headerlink" title="访问控制权限都有哪些?"></a>访问控制权限都有哪些?</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>	私有</span><br><span class="line"><span class="keyword">public</span>	公开</span><br><span class="line"><span class="keyword">protected</span>	受保护</span><br><span class="line">			默认（也就是前面啥也不写）</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="每个访问控制权限控制的范围是什么"><a href="#每个访问控制权限控制的范围是什么" class="headerlink" title="每个访问控制权限控制的范围是什么?"></a>每个访问控制权限控制的范围是什么?</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> 表示私有的，只能在本类中访问</span><br><span class="line"><span class="keyword">public</span> 表示公开的，在任何位置都可以访问</span><br><span class="line">“默认”表示只能在本类，以及同包下访问。</span><br><span class="line"><span class="keyword">protected</span>表示只能在本类、同包、子类中访问。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>访问控制修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>任意位置</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>默认</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">范围从大到小排序：<span class="keyword">public</span> &gt; <span class="keyword">protected</span> &gt; 默认 &gt; <span class="keyword">private</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="访问控制权限修饰符可以修饰什么？"><a href="#访问控制权限修饰符可以修饰什么？" class="headerlink" title="访问控制权限修饰符可以修饰什么？"></a>访问控制权限修饰符可以修饰什么？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">属性（<span class="number">4</span>个都能用）</span><br><span class="line">方法（<span class="number">4</span>个都能用）</span><br><span class="line">类（<span class="keyword">public</span>和默认能用，其它不行。）</span><br><span class="line">接口（<span class="keyword">public</span>和默认能用，其它不行。）</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="JDK类库的根类：Object"><a href="#JDK类库的根类：Object" class="headerlink" title="JDK类库的根类：Object"></a>JDK类库的根类：Object</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先我们要知道：</span><br><span class="line">任何一个类默认继承Object。就算没有直接继承，最终也会间接继承。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="源码及API文档概述"><a href="#源码及API文档概述" class="headerlink" title="源码及API文档概述"></a>源码及API文档概述</h2><blockquote>
<p>什么是API？<br>应用程序编程接口。（Application Program Interface）<br>整个JDK的类库就是一个javase的API。<br>每一个API都会配置一套API帮助文档。<br>SUN公司提前写好的这套类库就是API。（一般每一份API都对应一份API帮助文档。）</p>
</blockquote>
<blockquote>
<p>如何去查看API？<br><img src="https://img-blog.csdnimg.cn/20200809125659734.png" alt="1"><br><img src="https://img-blog.csdnimg.cn/20200809125743270.png" alt="2"><br>这里面便是全部java的API，他的帮助文档则可以在网上查阅得知，类容如下<br><img src="https://img-blog.csdnimg.cn/20200809125909795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<hr>
<h2 id="Object中的方法"><a href="#Object中的方法" class="headerlink" title="Object中的方法"></a>Object中的方法</h2><p>目前为止我们只需要知道这几个方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>   <span class="comment">// 负责对象克隆的。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>	<span class="comment">// 获取对象哈希值的一个方法。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>  <span class="comment">// 判断两个对象是否相等</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span>  <span class="comment">// 将对象转换成字符串形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span>  <span class="comment">// 垃圾回收器负责调用的方法</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Object中的方法–toString方法"><a href="#Object中的方法–toString方法" class="headerlink" title="Object中的方法–toString方法"></a>Object中的方法–toString方法</h3><p>1、源代码长什么样？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line">源代码上toString()方法的默认实现是：类名@对象的内存地址转换为十六进制再结合哈希算法得到的值的形式</span><br></pre></td></tr></table></figure>
<p>2、toString()方法的作用是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">toString()方法的设计目的是：</span><br><span class="line">通过调用这个方法可以将一个“java对象”转换成“字符串表示形式”</span><br></pre></td></tr></table></figure>
<p>3、<strong>其实SUN公司开发java语言的时候，建议所有的子类都去重写toString()方法。toString()方法应该是一个简洁的、详实的、易阅读的.</strong><br><img src="https://img-blog.csdnimg.cn/20200809130406585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="23"><br>4、在IDEA中如何使用？<br>在IDEA中能够自动为我们生成相应的覆盖toString方法，具体步骤如下：</p>
<blockquote>
<p>首先在类中同时按下键盘的 alt+insert 键，出现下图<br><img src="https://img-blog.csdnimg.cn/20200809130652977.png" alt="在这里插入图片描述"><br>然后选择 Override Methods中的toString<br><img src="https://img-blog.csdnimg.cn/20200809130811446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来就会自动生成了，在此基础上改为自己想要的样子即可。<br>观察可以发现，他同样可以自动生成 equals ，clone等方法，在后面就不再赘述。</p>
</blockquote>
<hr>
<h3 id="Object中的方法–equals方法"><a href="#Object中的方法–equals方法" class="headerlink" title="Object中的方法–equals方法"></a>Object中的方法–equals方法</h3><p>1、equals方法的源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、equals方法的目的是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">以后编程的过程当中，都要通过equals方法来判断两个对象是否相等。</span><br><span class="line">equals方法是判断两个对象是否相等的。</span><br></pre></td></tr></table></figure>
<p>3、Object类给的这个默认的equals方法够不够用？</p>
<blockquote>
<p>首先我们知道，在JAVA中去判断两个基本数据类型是否相等时，直接使用的是  ==  这个符号，例如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 判断两个基本数据类型的数据是否相等直接使用“==”就行。</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span>(a == b)</span><br><span class="line">		System.out.println(yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么问题来了，如何去判断两个对象是否相等，我们怎么办？能直接使用“==”吗？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先新建一个类:MyTime,里面包含年月日</span><br><span class="line">为了方便，不对其进行封装。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTime</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> year;</span><br><span class="line">	<span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">	<span class="comment">//提供构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTime</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTime</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.year = year;</span><br><span class="line">		<span class="keyword">this</span>.month = month;</span><br><span class="line">		<span class="keyword">this</span>.day = day;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个时候在主函数中去创建两个对象，令他们的 年月日 一样，那么我们可以认为这两个对象时相等（equal）的，但是直接用 == 可以吗？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyTime t1 = <span class="keyword">new</span> MyTime(<span class="number">2008</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">//MyTime t1 = 0x1234;</span></span><br><span class="line">MyTime t2 = <span class="keyword">new</span> MyTime(<span class="number">2008</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">//MyTime t2 = 0x3698;</span></span><br><span class="line">System.out.println(t1 == t2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>很显然不行，因为t1和t2是两个引用，他们保存的是对象的地址！<br>“==”符号是判断左右两边变量的值是否相等，就算对象内容相同，但是两个对象自然对应着两块不同的内存，所以equals方法在这里失效了（或者是没满足我们的要求）<br>在前面提到，当父类之中的方法无法满足子类的需求时，便需要对其进行覆盖重写。<br>equals到底应该怎么重写？你自己定，你认为两个对象什么相等的时候表示相等，你就怎么重写。（这个相等的标准是人为定的）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 当年相同，月相同，并且日也相同的时候，表示两个日期相同。两个对象相等。</span></span><br><span class="line">	<span class="keyword">if</span>(obj == <span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> MyTime))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	MyTime t = (MyTime)obj;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.year == t.year &amp;&amp; <span class="keyword">this</span>.month == t.month &amp;&amp; <span class="keyword">this</span>.day == t.day ;</span><br><span class="line">&#125;</span><br><span class="line">具体类容如上，学了前面的自然也看得懂，不再解释，同上toString方法，在IDEA中也能够自动生成。</span><br></pre></td></tr></table></figure>
<p>根据上述分析得出结论：Object类给的默认equals方法也是不够用的，用的时候建议覆盖重写。</p>
<p>4、总结equals</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java中基本数据类型比较是否相等，使用==</span><br><span class="line">java中所有的引用数据类型统一使用equals方法来判断是否相等。</span><br></pre></td></tr></table></figure>
<p>值得注意的是，String类中JAVA已经为我们写好了equals的重写方法，直接调用即可比较两字符串是否相等。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = a.equals(b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Object中的方法–finalize方法"><a href="#Object中的方法–finalize方法" class="headerlink" title="Object中的方法–finalize方法"></a>Object中的方法–finalize方法</h3><p>1、在Object类中的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br><span class="line">要知道的是</span><br><span class="line">该方法在最新的jdk已经过时了，此方法不重要，了解即可</span><br><span class="line">该方法不是由程序员手动调动的，是由GC（垃圾回收器）自动调用的</span><br></pre></td></tr></table></figure>
<p>2、finalize()方法的执行时机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用finalize()方法。</span><br></pre></td></tr></table></figure>
<p>3、提示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java中的垃圾回收器不是轻易启动的</span><br><span class="line">垃圾太少，或者时间没到，种种条件下，有可能启动，也有可能不启动。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Object中的方法–hashCode方法"><a href="#Object中的方法–hashCode方法" class="headerlink" title="Object中的方法–hashCode方法"></a>Object中的方法–hashCode方法</h3><p>在Object中的hashCode方法是怎样的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">这个方法不是抽象方法，带有<span class="keyword">native</span>关键字，底层调用C++程序。</span><br><span class="line">hashCode()方法返回的是哈希码：</span><br><span class="line">	实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值。</span><br><span class="line">	所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址。</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记12-（一维数组）</title>
    <url>/2020/08/10/java_study_12/</url>
    <content><![CDATA[<p>JAVA学习笔记12-（一维数组）</p>
<a id="more"></a>



<hr>
<h1 id="数组介绍："><a href="#数组介绍：" class="headerlink" title="数组介绍："></a>数组介绍：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、Java语言中的数组是一种引用数据类型。不属于基本数据类型。数组的父类是Object。</span><br><span class="line"><span class="number">2</span>、数组当中可以存储“基本数据类型”的数据，也可以存储“引用数据类型”的数据。</span><br><span class="line"><span class="number">3</span>、数组因为是引用类型，所以数组对象是堆内存当中。（数组是存储在堆当中的）</span><br><span class="line"><span class="number">4</span>、数组当中如果存储的是“java对象”的话，实际上存储的是对象的“引用（内存地址）”，数组中不能直接存储java对象。</span><br><span class="line"><span class="number">5</span>、数组一旦创建，在java中规定，长度不可变。（数组长度不可变）</span><br><span class="line"><span class="number">6</span>、所有的数组对象都有length属性(java自带的)，用来获取数组中元素的个数。</span><br><span class="line"><span class="number">7</span>、所有的数组都是拿“第一个小方框的内存地址”作为整个数组对象的内存地址。（数组中首元素的内存地址作为整个数组对象的内存地址。）</span><br><span class="line"><span class="number">8</span>、数组这种数据结构的优点和缺点是什么？</span><br><span class="line">	优点：查询/查找/检索某个下标上的元素时效率极高。可以说是查询效率最高的一个数据结构。</span><br><span class="line">		为什么检索效率高？</span><br><span class="line">			第一：每一个元素的内存地址在空间存储上是连续的。</span><br><span class="line">			第二：每一个元素类型相同，所以占用空间大小一样。</span><br><span class="line">			第三：知道第一个元素内存地址，知道每一个元素占用空间的大小，又知道下标，所以通过一个数学表达式就可以计算出某个下标上元素的内存地址。直接通过内存地址定位元素，所以数组的检索效率是最高的。</span><br><span class="line">	缺点：</span><br><span class="line">		第一：由于为了保证数组中每个元素的内存地址连续，所以在数组上随机删除或者增加元素的时候，效率较低，因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作。</span><br><span class="line">		第二：数组不能存储大数据量，因为很难在内存空间上找到一块特别大的连续的内存空间。</span><br><span class="line">	注意：对于数组中最后一个元素的增删，是没有效率影响的。</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数组语法："><a href="#数组语法：" class="headerlink" title="数组语法："></a>数组语法：</h1><p>怎么声明/定义一个一维数组？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1;</span><br><span class="line"><span class="keyword">double</span>[] array2;</span><br><span class="line"><span class="keyword">boolean</span>[] array3;</span><br><span class="line">String[] array4;</span><br><span class="line">Object[] array5;</span><br></pre></td></tr></table></figure>
<p>怎么初始化一个一维数组呢？<br>包括两种方式：静态初始化一维数组，动态初始化一维数组。</p>
<p>静态初始化语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">100</span>, <span class="number">2100</span>, <span class="number">300</span>, <span class="number">55</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>动态初始化语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">这里的<span class="number">5</span>表示数组的元素个数。初始化一个<span class="number">5</span>个长度的<span class="keyword">int</span>类型数组，每个元素默认值<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>用length去获得数组的长度（元素的个数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">55</span>, <span class="number">689</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中元素的个数&quot;</span> + a.length);<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="关于每个类型的默认值："><a href="#关于每个类型的默认值：" class="headerlink" title="关于每个类型的默认值："></a>关于每个类型的默认值：</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>引用数据类型</td>
<td>null</td>
</tr>
</tbody></table>
<hr>
<h2 id="当一个方法参数的类型是一个数组时："><a href="#当一个方法参数的类型是一个数组时：" class="headerlink" title="当一个方法参数的类型是一个数组时："></a>当一个方法参数的类型是一个数组时：</h2><p>当一个方法上，参数的类型是一个数组的时候。<br>在传参时直接将数组名字传进去即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	printArray(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">		System.out.println(array[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="main方法上面的“String-args”解释："><a href="#main方法上面的“String-args”解释：" class="headerlink" title="main方法上面的“String[] args”解释："></a>main方法上面的“String[] args”解释：</h2><p>JVM调用main方法的时候，会自动传一个String数组过来。<br>首先我们来看看这个数组的长度是多少：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;JVM给传递过来的String数组参数，它这个数组的长度是？&quot;</span> + args.length);</span><br><span class="line">得到的结果是<span class="number">0</span></span><br><span class="line">通过测试得出：args不是<span class="keyword">null</span>。</span><br></pre></td></tr></table></figure>
<p>这个数组什么时候里面会有值呢？<br>其实这个数组是留给用户的，用户可以在控制台上输入参数，这个参数自动会被转换为“String[] args”<br>如何在IDEA中去输入这个参数呢？如下图：<br><img src="https://img-blog.csdnimg.cn/20200812082950938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200812082955918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到，我们在这里输入了abc，那么此时的args数组长度就为1且args[0]就是abc了。</p>
<hr>
<h2 id="一维数组的扩容和拷贝"><a href="#一维数组的扩容和拷贝" class="headerlink" title="一维数组的扩容和拷贝"></a>一维数组的扩容和拷贝</h2><p>在java开发中，数组长度一旦确定不可变，那么数组满了怎么办？<br>数组满了，需要扩容。<br>java中对数组的扩容是：<br>先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。<br>JAVA为我们提供了一个arraycopy的方法来对数组进行拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(<span class="number">5</span>个参数);</span><br></pre></td></tr></table></figure>
<p>具体是哪五个参数？如下是arraycopy的源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,Object dest, <span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span>;</span><br><span class="line">第一个src是拷贝源（从这个数组中拷贝）</span><br><span class="line">第二个srcPos是拷贝源中的起点（从下标为几的位置开始拷贝）</span><br><span class="line">第三个dest是拷贝目标（拷贝到这个目标数组上）</span><br><span class="line">第四个destPos是拷贝目标中的起点（从下标为几的地方开始接受拷贝）</span><br><span class="line">第五个length是拷贝的长度（从拷贝源src的srcPos开始向后拷贝length长度的内容）</span><br></pre></td></tr></table></figure>

<p>如下代码完成了对一个数组的拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝源（从这个数组中拷贝）</span></span><br><span class="line"><span class="keyword">int</span>[] src = &#123;<span class="number">1</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝目标（拷贝到这个目标数组上）</span></span><br><span class="line"><span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>]; <span class="comment">// 动态初始化一个长度为20的数组，每一个元素默认值0</span></span><br><span class="line"></span><br><span class="line">System.arraycopy(src, <span class="number">0</span>, dest, <span class="number">0</span>, src.length);</span><br></pre></td></tr></table></figure>
<p>这就完成了吧src数组中的全部内容拷贝到dest中</p>
<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记11-（匿名内部类）</title>
    <url>/2020/08/09/java_study_11/</url>
    <content><![CDATA[<p>JAVA学习笔记11-（匿名内部类）</p>
<a id="more"></a>



<hr>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、什么是内部类？</span><br><span class="line">	内部类：在类的内部又定义了一个新的类。被称为内部类。</span><br><span class="line"><span class="number">2</span>、内部类的分类：</span><br><span class="line">	静态内部类：类似于静态变量</span><br><span class="line">	实例内部类：类似于实例变量</span><br><span class="line">	局部内部类：类似于局部变量</span><br><span class="line"><span class="number">3</span>、使用内部类编写的代码，可读性很差。能不用尽量不用。学习仅仅是为了了解，能看懂别人写的代码。</span><br><span class="line"><span class="number">4</span>、匿名内部类是局部内部类的一种。因为这个类没有名字而得名，叫做匿名内部类。</span><br><span class="line"><span class="number">5</span>、匿名内部类有两个缺点：</span><br><span class="line">	缺点<span class="number">1</span>：太复杂，太乱，可读性差。</span><br><span class="line">	缺点<span class="number">2</span>：类没有名字，以后想重复使用，不能用。</span><br></pre></td></tr></table></figure>
<p>内部类的代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test01</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span></span>&#123;&#125;<span class="comment">//静态内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner2</span></span>&#123;&#125;<span class="comment">//实例内部类</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Inner3</span></span>&#123;&#125;<span class="comment">//局部内部类</span></span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何使用匿名内部类？首先来创建一个接口和类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负责计算的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Compute</span></span>&#123;</span><br><span class="line">	<span class="comment">//求和的抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数学类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mySum</span><span class="params">(Compute c, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> retValue = c.sum(x, y);</span><br><span class="line">		System.out.println(x + <span class="string">&quot;+&quot;</span> + y + <span class="string">&quot;=&quot;</span> + retValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想在主函数中去调用sum方法，不难想象我们必须要写一个对Compute的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputeImpl</span> <span class="keyword">implements</span> <span class="title">Compute</span></span>&#123;</span><br><span class="line">	<span class="comment">// 对方法的实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后如下在主函数中调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	MyMath mm = <span class="keyword">new</span> MyMath();</span><br><span class="line">	Compute c = <span class="keyword">new</span> ComputeImpl();</span><br><span class="line">	mm.mySum(c, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">	mm.mySum(<span class="keyword">new</span> ComputeImpl(), <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>+<span class="number">200</span>=<span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>这个时候，有些人可能会用匿名内部类了（为啥要这么写···不是有问题吗···）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mm.mySum(<span class="keyword">new</span> Compute()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,<span class="number">200</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure>
<p>如上写法就是匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用匿名内部类，表示这个ComputeImpl这个类没名字了。</span><br><span class="line">这里表面看上去好像是接口可以直接<span class="keyword">new</span>了，实际上并不是接口可以<span class="keyword">new</span>了。</span><br><span class="line">后面的&#123;&#125; 代表了对接口的实现。</span><br><span class="line">不建议使用匿名内部类，为什么？</span><br><span class="line">因为一个类没有名字，没有办法重复使用。另外代码太乱，可读性太差。</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记13-（二维数组和数组工具类）</title>
    <url>/2020/08/11/java_study_13/</url>
    <content><![CDATA[<p>JAVA学习笔记13-（二维数组和数组工具类）</p>
<a id="more"></a>



<hr>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、二维数组其实是一个特殊的一维数组，特殊在这个一维数组当中的每一个元素是一个一维数组。</span><br><span class="line"><span class="number">2</span>、二维数组静态初始化</span><br><span class="line">	<span class="keyword">int</span>[][] array = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="number">3</span>、二维数组的动态初始化</span><br><span class="line">	<span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>];三行四列的二维数组，相当于每一行都是一个一维数组，每个一维数组中<span class="number">4</span>个元素。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="关于Object的小tips"><a href="#关于Object的小tips" class="headerlink" title="关于Object的小tips"></a>关于Object的小tips</h2><p>如果要求一个数组可以存储java中的任何引用类型的数据。这个数组的类型是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object类</span><br><span class="line">Object[] array = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>因为Object是所有引用数据类型的父类，所以可以去存储任何引用类型的数据。</p>
<hr>
<h1 id="数组工具类Arrays"><a href="#数组工具类Arrays" class="headerlink" title="数组工具类Arrays"></a>数组工具类Arrays</h1><p>JAVA为我们提供了一套数组工具，包含了各种写好的算法，来完成对数组的查找和排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在java.util.Arrays包下</span><br></pre></td></tr></table></figure>
<p>在JAVA源代码和API中查阅如下：<br><img src="https://img-blog.csdnimg.cn/20200813083048913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200813083053697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>值得注意的是，工具类当中的方法大部分都是静态的。通过类名.方法名直接调用即可。<br>例如对一个数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">112</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">完成排序</span><br></pre></td></tr></table></figure>

<p><strong>关于具体的Arrays中有哪些方法，则需要在实际应用中查阅API即可。</strong></p>
<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记15-（包装类）</title>
    <url>/2020/08/13/java_study_15/</url>
    <content><![CDATA[<p>JAVA学习笔记15-（包装类）</p>
<a id="more"></a>



<hr>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>java中为8种基本数据类型又对应准备了8种包装类型。8种包装类属于引用数据类型，父类是Object。<br>思考：为什么要再提供8种包装类呢？<br>因为8种基本数据类型不够用。<br>所以SUN又提供对应的8种包装类型。</p>
<p>什么叫不够用？<br>例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">有没有这种需求：调用doSome()方法的时候需要传一个数字进去。</span><br><span class="line">但是数字属于基本数据类型，而doSome()方法参数的类型是Object。</span><br><span class="line">可见doSome()方法无法接收基本数据类型的数字。那怎么办呢？可以传一个数字对应的包装类进去。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8种基本数据类型对应的包装类型名"><a href="#8种基本数据类型对应的包装类型名" class="headerlink" title="8种基本数据类型对应的包装类型名"></a>8种基本数据类型对应的包装类型名</h2><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>java.lang.Byte（父类Number）</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short（父类Number)</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer（父类Number）</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long（父类Number）</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float（父类Number）</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double（父类Number）</td>
</tr>
<tr>
<td>boolean</td>
<td>java.lang.Boolean（父类Object）</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Character（父类Object）</td>
</tr>
</tbody></table>
<p>以上八种包装类中，重点以java.lang.Integer为代表进行学习，其它的类型照葫芦画瓢就行。</p>
<p>八种包装类中其中6个都是数字对应的包装类，他们的父类都是Number，可以先研究一下Number中公共的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number是一个抽象类，无法实例化对象。</span><br><span class="line">Number类中有这样的方法：</span><br><span class="line">        <span class="function"><span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span> 以 <span class="keyword">byte</span> 形式返回指定的数值。</span></span><br><span class="line"><span class="function">        <span class="keyword">abstract</span>  <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span>以 <span class="keyword">double</span> 形式返回指定的数值。</span></span><br><span class="line"><span class="function">        <span class="keyword">abstract</span>  <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span>以 <span class="keyword">float</span> 形式返回指定的数值。</span></span><br><span class="line"><span class="function">        <span class="keyword">abstract</span>  <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span>以 <span class="keyword">int</span> 形式返回指定的数值。</span></span><br><span class="line"><span class="function">        <span class="keyword">abstract</span>  <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span>以 <span class="keyword">long</span> 形式返回指定的数值。</span></span><br><span class="line"><span class="function">        <span class="keyword">short</span> <span class="title">shortValue</span><span class="params">()</span>以 <span class="keyword">short</span> 形式返回指定的数值。</span></span><br><span class="line"><span class="function">        这些方法其实所有的数字包装类的子类都有，这些方法是负责拆箱的。</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是装箱和拆箱？"><a href="#什么是装箱和拆箱？" class="headerlink" title="什么是装箱和拆箱？"></a>什么是装箱和拆箱？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基本数据类型 -(转换为)-&gt;引用数据类型（装箱）</span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">此方法已过时，现在用的是自动装箱</span><br><span class="line">Integer x = <span class="number">900</span>;</span><br><span class="line"></span><br><span class="line">将引用数据类型--(转换为)-&gt; 基本数据类型（拆箱）</span><br><span class="line"><span class="keyword">int</span> retValue = i.intValue();</span><br><span class="line">也可以这样，自动拆箱</span><br><span class="line"><span class="keyword">int</span> retValue = i;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h2><p>在java5之后，引入了一种新特性，自动装箱和自动拆箱。<br>自动装箱：基本数据类型自动转换成包装类。<br>自动拆箱：包装类自动转换成基本数据类型。<br>不再调用Number中的方法，而是直接写即可，方便编程。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">自动装箱</span><br><span class="line">基本数据类型 --(自动转换)--&gt; 包装类型：自动装箱</span><br><span class="line">Integer x = <span class="number">900</span>;</span><br><span class="line"></span><br><span class="line">自动拆箱</span><br><span class="line">包装类型 --(自动转换)--&gt; 基本数据类型：自动拆箱</span><br><span class="line"><span class="keyword">int</span> y = x;</span><br></pre></td></tr></table></figure>
<p>关于自动装箱和自动拆箱的方便之处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">z是一个引用，z是一个变量，z还是保存了一个对象的内存地址。</span><br><span class="line">Integer z = <span class="number">1000</span>;</span><br><span class="line">等同于：Integer z = <span class="keyword">new</span> Integer(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(z + <span class="number">1</span>);</span><br><span class="line">答案是<span class="number">1001</span></span><br><span class="line">分析为什么这个没有报错呢？</span><br><span class="line"><span class="string">&quot;+&quot;</span>两边要求是基本数据类型的数字，z是包装类，不属于基本数据类型。</span><br><span class="line">这里会进行自动拆箱。将z转换成基本数据类型</span><br><span class="line">在java5之前你这样写肯定编译器报错。</span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">1000</span>;</span><br><span class="line">等同于：Integer a = <span class="keyword">new</span> Integer(<span class="number">1000</span>); a是个引用，保存内存地址指向对象。</span><br><span class="line">Integer b = <span class="number">1000</span>;</span><br><span class="line">等同于：Integer b = <span class="keyword">new</span> Integer(<span class="number">1000</span>); b是个引用，保存内存地址指向对象。</span><br><span class="line"></span><br><span class="line">System.out.println(a == b);</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">== 比较的是对象的内存地址，a和b两个引用中保存的对象内存地址不同。</span><br><span class="line">== 这个运算符不会触发自动拆箱机制。（只有+ - * /等运算的时候才会。）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="通过访问包装类的常量，来获取最大值和最小值"><a href="#通过访问包装类的常量，来获取最大值和最小值" class="headerlink" title="通过访问包装类的常量，来获取最大值和最小值"></a>通过访问包装类的常量，来获取最大值和最小值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;int的最大值：&quot;</span> + Integer.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;int的最小值：&quot;</span> + Integer.MIN_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;byte的最大值：&quot;</span> + Byte.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;byte的最小值：&quot;</span> + Byte.MIN_VALUE);</span><br><span class="line">这样就可以获得每个数据类型对应的最大值和最小值了，不用再记。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关于Integer的一个重要题目："><a href="#关于Integer的一个重要题目：" class="headerlink" title="关于Integer的一个重要题目："></a>关于Integer的一个重要题目：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">128</span>;</span><br><span class="line">Integer b = <span class="number">128</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">结果是<span class="keyword">false</span>并不意外，因为a和b是两个引用，他们虽然指向的值相同，但是他们中保存的地址却不相同。</span><br></pre></td></tr></table></figure>
<p>那么下面这段代码呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="number">127</span>;</span><br><span class="line">Integer y = <span class="number">127</span>;</span><br><span class="line">System.out.println(x == y);</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">结果却是<span class="keyword">true</span>！</span><br><span class="line">难道关于==的说明出了问题？</span><br><span class="line">不是！== 永远判断的都是两个对象的内存地址是否相同！</span><br><span class="line">那么我们就可以知道，其实这两个引用（x和y）存的是同一块内存地址！</span><br></pre></td></tr></table></figure>
<p><strong>重点！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java中为了提高程序的执行效率</span><br><span class="line">将[-<span class="number">128</span>到<span class="number">127</span>]之间所有的包装对象提前创建好，放到了一个方法区的“整数型常量池”当中了</span><br><span class="line">目的是只要用这个区间的数据不需要再<span class="keyword">new</span>了，直接从整数型常量池当中取出来。</span><br><span class="line">（可以类比于String的字符串常量池）</span><br><span class="line">（一切都是为了提高效率！）</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200814103553242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>所以这就与</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">== 永远判断的都是两个对象的内存地址是否相同。</span><br></pre></td></tr></table></figure>
<p>不矛盾了。</p>
<hr>
<h2 id="Integer类当中常用的方法"><a href="#Integer类当中常用的方法" class="headerlink" title="Integer类当中常用的方法"></a>Integer类当中常用的方法</h2><p>在Integer类中有很多方法，这里仅介绍常用的，剩下的和其他包装类均可在API中查阅。<br>API链接: <a href="https://www.apiref.com/java11-zh/index.html">JDK11版本</a>.<br>API链接: <a href="https://www.matools.com/api/java8">JDK8版本</a>.</p>
<hr>
<h3 id="NumberFormatException"><a href="#NumberFormatException" class="headerlink" title="NumberFormatException"></a>NumberFormatException</h3><p>首先介绍一个在这里可能会出现的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数字格式化异常：NumberFormatException</span><br></pre></td></tr></table></figure>
<p>当在进行包装时，如果对应的数据类型错误，那么就会产生这种异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">不是一个“数字”可以包装成Integer吗？不能。运行时出现异常。</span><br><span class="line">java.lang.NumberFormatException</span><br></pre></td></tr></table></figure>

<p>在这里总结一下已经学习的经典异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">空指针异常：NullPointerException</span><br><span class="line">类型转换异常：ClassCastException</span><br><span class="line">数组下标越界异常：ArrayIndexOutOfBoundsException</span><br><span class="line">数字格式化异常：NumberFormatException</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="重点方法static-int-parseInt-String-s"><a href="#重点方法static-int-parseInt-String-s" class="headerlink" title="重点方法static int parseInt(String s)"></a>重点方法static int parseInt(String s)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态方法，传参String，返回<span class="keyword">int</span></span><br><span class="line">作用是将 String -转换-&gt; <span class="keyword">int</span></span><br><span class="line">例如：网页上文本框中输入的<span class="number">100</span>实际上是<span class="string">&quot;100&quot;</span>字符串。后台数据库中要求存储<span class="number">100</span>数字，此时java程序需要将<span class="string">&quot;100&quot;</span>转换成<span class="number">100</span>数字。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> retValue = Integer.parseInt(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(retValue + <span class="number">100</span>);</span><br><span class="line"><span class="number">223</span></span><br><span class="line"></span><br><span class="line">但是这样不行哦！</span><br><span class="line"><span class="keyword">int</span> retValue = Integer.parseInt(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">NumberFormatException</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="其他方法（了解即可）"><a href="#其他方法（了解即可）" class="headerlink" title="其他方法（了解即可）"></a>其他方法（了解即可）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-----------------------------------以下内容作为了解，不需要掌握---------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toBinaryString</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">静态的：将十进制转换成二进制字符串。</span></span><br><span class="line"><span class="function">String binaryString </span>= Integer.toBinaryString(<span class="number">3</span>);</span><br><span class="line">System.out.println(binaryString); <span class="comment">//&quot;11&quot; 二进制字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">静态的：将十进制转换成十六进制字符串。</span></span><br><span class="line"><span class="function">String hexString </span>= Integer.toHexString(<span class="number">16</span>);</span><br><span class="line">System.out.println(hexString); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">十六进制：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> a b c d e f</span><br><span class="line">hexString = Integer.toHexString(<span class="number">17</span>);</span><br><span class="line">System.out.println(hexString); <span class="comment">// &quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toOctalString</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">静态的：将十进制转换成八进制字符串。</span></span><br><span class="line"><span class="function">String octalString </span>= Integer.toOctalString(<span class="number">8</span>);</span><br><span class="line">System.out.println(octalString); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> Object()); <span class="comment">//java.lang.Object@6e8cf4c6</span></span><br><span class="line"></span><br><span class="line">valueOf方法作为了解</span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">静态的：<span class="keyword">int</span>--&gt;Integer</span></span><br><span class="line"><span class="function">Integer i1 </span>= Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">System.out.println(i1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">静态的：String--&gt;Integer</span></span><br><span class="line"><span class="function">Integer i2 </span>= Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">System.out.println(i2);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="String-int-Integer之间互相转换"><a href="#String-int-Integer之间互相转换" class="headerlink" title="String int Integer之间互相转换"></a>String int Integer之间互相转换</h2><p>首先如下图，这三者之间的互相转换可以用以下方法：<br><img src="https://img-blog.csdnimg.cn/2020081410532641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String --&gt; <span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span> i1 = Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// i1是100数字</span></span><br><span class="line">System.out.println(i1 + <span class="number">1</span>); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> --&gt; String</span><br><span class="line">String s2 = i1 + <span class="string">&quot;&quot;</span>; <span class="comment">// &quot;100&quot;字符串</span></span><br><span class="line">System.out.println(s2 + <span class="number">1</span>); <span class="comment">// &quot;1001&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> --&gt; Integer</span><br><span class="line">自动装箱</span><br><span class="line">Integer x = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">Integer --&gt; <span class="keyword">int</span></span><br><span class="line">自动拆箱</span><br><span class="line"><span class="keyword">int</span> y = x;</span><br><span class="line"></span><br><span class="line">String --&gt; Integer</span><br><span class="line">Integer k = Integer.valueOf(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">Integer --&gt; String</span><br><span class="line">String e = String.valueOf(k);</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记16-（日期，随机数，枚举）</title>
    <url>/2020/08/14/java_study_16/</url>
    <content><![CDATA[<p>JAVA学习笔记16-（日期，随机数，枚举）</p>
<a id="more"></a>



<hr>
<h1 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h1><p>JAVA中的日期是一个Date类来完成的</p>
<hr>
<h2 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a>获取系统当前时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取系统当前时间（精确到毫秒的系统当前时间）</span><br><span class="line">Date nowTime = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(nowTime);</span><br><span class="line">会输出下面的格式（默认输出格式）</span><br><span class="line">Thu Mar <span class="number">05</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">06</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<p>日期可以格式化吗？<br>将日期类型Date，按照指定的格式进行转换：<br>Date –转换成具有一定格式的日期字符串–&gt;String</p>
<p>SimpleDateFormat是java.text包下的。专门负责日期格式化的。<br>其中包括的具体格式见API<br><img src="https://img-blog.csdnimg.cn/20200814160438704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其中常用的如下：</span><br><span class="line">yyyy 年(年是<span class="number">4</span>位)</span><br><span class="line">MM 月（月是<span class="number">2</span>位）</span><br><span class="line">dd 日</span><br><span class="line">HH 时</span><br><span class="line">mm 分</span><br><span class="line">ss 秒</span><br><span class="line">SSS 毫秒（毫秒<span class="number">3</span>位，最高<span class="number">999</span>。<span class="number">1000</span>毫秒代表<span class="number">1</span>秒）</span><br><span class="line">注意：在日期格式中，除了y M d H m s S这些字符不能随便写之外，剩下的符号格式自己随意组织。</span><br><span class="line">例如：</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">String nowTimeStr = sdf.format(nowTime);</span><br><span class="line">System.out.println(nowTimeStr);</span><br><span class="line"></span><br><span class="line">那么则会输出：<span class="number">2020</span>-<span class="number">8</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">05</span>:<span class="number">19</span> <span class="number">006</span></span><br><span class="line"></span><br><span class="line">其实本质上就是将Date转为String字符串</span><br></pre></td></tr></table></figure>

<p>那么假设现在有一个日期字符串String，怎么转换成Date类型？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String --&gt; Date</span><br><span class="line">String time = <span class="string">&quot;2008-08-08 08:08:08 888&quot;</span>;</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;格式不能随便写，要和日期字符串格式相同&quot;</span>);</span><br><span class="line"></span><br><span class="line">注意：字符串的日期格式和SimpleDateFormat对象指定的日期格式要一致。不然会出现异常：java.text.ParseException</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">Date dateTime = sdf2.parse(time);</span><br><span class="line">System.out.println(dateTime); </span><br><span class="line">Fri Aug <span class="number">08</span> <span class="number">08</span>:<span class="number">08</span>:<span class="number">08</span> CST <span class="number">2008</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="获取自1970年1月1日-00-00-00-000到当前系统时间的总毫秒数。"><a href="#获取自1970年1月1日-00-00-00-000到当前系统时间的总毫秒数。" class="headerlink" title="获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。"></a>获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。</h2><blockquote>
<p>1秒 = 1000毫秒</p>
</blockquote>
<p>要获得自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数，需要调用System类中的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.currentTimeMillis();</span><br></pre></td></tr></table></figure>
<p>这个方法能有什么用呢？<br>我们可以通过他来去统计执行一个方法的耗时！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">统计一个方法耗时</span><br><span class="line"></span><br><span class="line">在调用目标方法之前记录一个毫秒数</span><br><span class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">调用方法;</span><br><span class="line"></span><br><span class="line">在执行完目标方法之后记录一个毫秒数</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;耗费时长&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Date的含参构造方法"><a href="#Date的含参构造方法" class="headerlink" title="Date的含参构造方法"></a>Date的含参构造方法</h2><p>在API中，我们注意到Date还有一个构造方法：（已过时的方法不予学习）<br><img src="https://img-blog.csdnimg.cn/20200814161205688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们可以在创建对象时去传一个参数进去！<br>那么这样是干什么的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这个时间是什么时间？</span><br><span class="line">Date time = <span class="keyword">new</span> Date(<span class="number">1</span>);</span><br><span class="line">注意：参数是一个毫秒</span><br><span class="line"></span><br><span class="line">其实这个time代表的是如下时间</span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">001</span></span><br><span class="line"></span><br><span class="line">那么这个传参的意思就出来了</span><br><span class="line">他的意思是从<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">000</span>开始，过了<span class="string">&quot;date&quot;</span>毫秒后的时间！</span><br></pre></td></tr></table></figure>

<p>那么我们可以以此去获得昨天此时的时间（更多玩法自己开发）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">Date time2 = <span class="keyword">new</span> Date(System.currentTimeMillis() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">1000</span>毫秒=<span class="number">1</span>秒</span><br><span class="line"><span class="number">1</span>分钟=<span class="number">60</span>秒</span><br><span class="line"><span class="number">1</span>小时=<span class="number">60</span>分钟</span><br><span class="line"><span class="number">1</span>天=<span class="number">24</span>小时</span><br><span class="line"></span><br><span class="line">String strTime2 = sdf.format(time2);</span><br><span class="line">System.out.println(strTime2);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数字number"><a href="#数字number" class="headerlink" title="数字number"></a>数字number</h1><p>在java.text也有关于number的一些东西</p>
<hr>
<h2 id="数字的格式化DecimalFormat"><a href="#数字的格式化DecimalFormat" class="headerlink" title="数字的格式化DecimalFormat"></a>数字的格式化DecimalFormat</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用法</span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;数字格式&quot;</span>);</span><br><span class="line"></span><br><span class="line">数字格式有哪些？</span><br><span class="line"># 代表任意数字</span><br><span class="line">, 代表千分位</span><br><span class="line">. 代表小数点</span><br><span class="line"><span class="number">0</span> 代表不够时补<span class="number">0</span></span><br><span class="line"></span><br><span class="line">###,###.##</span><br><span class="line">表示：加入千分位，保留<span class="number">2</span>个小数。</span><br></pre></td></tr></table></figure>
<p>具体用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;###,###.##&quot;</span>);</span><br><span class="line">String s = df.format(<span class="number">1234.561234</span>);</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="string">&quot;1,234.56&quot;</span></span><br><span class="line"></span><br><span class="line">DecimalFormat df2 = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;###,###.0000&quot;</span>);</span><br><span class="line">保留<span class="number">4</span>个小数位，不够补上<span class="number">0</span></span><br><span class="line">String s2 = df2.format(<span class="number">1234.56</span>);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"><span class="string">&quot;1,234.5600&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="高精度数据BigDecimal"><a href="#高精度数据BigDecimal" class="headerlink" title="高精度数据BigDecimal"></a>高精度数据BigDecimal</h2><p>一般来说在财务软件中double是不够的，所以有了这个数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal</span><br></pre></td></tr></table></figure>

<p>具体用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这个<span class="number">100</span>不是普通的<span class="number">100</span>，是精度极高的<span class="number">100</span></span><br><span class="line">BigDecimal v1 = <span class="keyword">new</span> BigDecimal(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">精度极高的<span class="number">200</span></span><br><span class="line">BigDecimal v2 = <span class="keyword">new</span> BigDecimal(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">求和</span><br><span class="line"></span><br><span class="line">v1 + v2;</span><br><span class="line">这样不行，v1和v2都是引用，不能直接使用+求和。</span><br><span class="line"></span><br><span class="line">BigDecimal v3 = v1.add(v2);</span><br><span class="line">调用方法求和。</span><br><span class="line"></span><br><span class="line">System.out.println(v3);</span><br><span class="line"><span class="number">300</span></span><br><span class="line"></span><br><span class="line">BigDecimal v4 = v2.divide(v1);</span><br><span class="line">System.out.println(v4);</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建随机数对象</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">随机产生一个<span class="keyword">int</span>类型取值范围内的数字。</span><br><span class="line"><span class="keyword">int</span> num1 = random.nextInt();</span><br><span class="line">System.out.println(num1);</span><br><span class="line"></span><br><span class="line">产生[<span class="number">0</span>~<span class="number">100</span>]之间的随机数。不能产生<span class="number">101</span>。</span><br><span class="line">nextInt翻译为：下一个<span class="keyword">int</span>类型的数据是<span class="number">101</span>，表示只能取到<span class="number">100.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num2 = random.nextInt(<span class="number">101</span>);</span><br><span class="line">不包括<span class="number">101</span></span><br><span class="line">System.out.println(num2);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>enum<br>具体用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">	枚举值<span class="number">1</span>,枚举值<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如去建造一个枚举类，其中包括成功和失败：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Result&#123;</span><br><span class="line">    SUCCESS, FAIL</span><br><span class="line">&#125;</span><br><span class="line">SUCCESS 是枚举Result类型中的一个值</span><br><span class="line">FAIL 是枚举Result类型中的一个值</span><br><span class="line">枚举中的每一个值，可以看做是“常量”</span><br></pre></td></tr></table></figure>
<p>而在函数中直接调用的话就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result.SUCCESS</span><br><span class="line">Result.FAIL</span><br></pre></td></tr></table></figure>

<p>当然也可以结合switch使用，例如下面我们创建一个四季枚举类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">春夏秋冬</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用switch去调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Season season = Season.AUTUMN;</span><br><span class="line"><span class="keyword">switch</span> (season) &#123;</span><br><span class="line">	必须省略Season.</span><br><span class="line">	<span class="keyword">case</span> SPRING:</span><br><span class="line">		System.out.println(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SUMMER:</span><br><span class="line">		System.out.println(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AUTUMN:</span><br><span class="line">		System.out.println(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WINTER:</span><br><span class="line">		System.out.println(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">秋天</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记18-（集合①）</title>
    <url>/2020/08/16/java_study_18/</url>
    <content><![CDATA[<p>JAVA学习笔记18-（集合①）</p>
<a id="more"></a>



<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集合是JAVA中为我们提供的一种“容器”，可以存储东西。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1</span>、什么是集合？有什么用？</span><br><span class="line"></span><br><span class="line">	数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其它类型的数据。</span><br><span class="line"></span><br><span class="line">集合为什么说在开发中使用较多？</span><br><span class="line">			集合是一个容器，是一个载体，可以一次容纳多个对象。</span><br><span class="line">			在实际开发中，假设连接数据库，数据库当中有<span class="number">10</span>条记录，</span><br><span class="line">			那么假设把这<span class="number">10</span>条记录查询出来，在java程序中会将<span class="number">10</span>条</span><br><span class="line">			数据封装成<span class="number">10</span>个java对象，然后将<span class="number">10</span>个java对象放到某一个</span><br><span class="line">			集合当中，将集合传到前端，然后遍历集合，将一个数据一个</span><br><span class="line">			数据展现出来。</span><br><span class="line">			</span><br><span class="line"><span class="number">1.2</span>、集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，</span><br><span class="line"></span><br><span class="line">	集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用。）</span><br><span class="line">		list.add(<span class="number">100</span>); <span class="comment">//自动装箱Integer</span></span><br><span class="line">		注意：</span><br><span class="line">			集合在java中本身是一个容器，是一个对象。</span><br><span class="line">			集合中任何时候存储的都是“引用”。</span><br><span class="line">			</span><br><span class="line"><span class="number">1.3</span>、在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中</span><br><span class="line"></span><br><span class="line">存储元素，等于将数据放到了不同的数据结构当中。</span><br><span class="line">什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储方式不同。</span><br><span class="line">例如：</span><br><span class="line">		数组、二叉树、链表、哈希表...</span><br><span class="line">		以上这些都是常见的数据结构。</span><br><span class="line">		<span class="keyword">new</span> ArrayList(); 创建一个集合，底层是数组。</span><br><span class="line">		<span class="keyword">new</span> LinkedList(); 创建一个集合对象，底层是链表。</span><br><span class="line">		<span class="keyword">new</span> TreeSet(); 创建一个集合对象，底层是二叉树。</span><br><span class="line"></span><br><span class="line"><span class="number">1.4</span>、集合在java JDK中哪个包下？</span><br><span class="line"></span><br><span class="line">	java.util.*;</span><br><span class="line">	所有的集合类和集合接口都在java.util包下。</span><br><span class="line">			</span><br><span class="line"><span class="number">1.5</span>、在java中集合分为两大类：</span><br><span class="line"></span><br><span class="line">一类是单个方式存储元素：</span><br><span class="line">	单个方式存储元素，这一类集合中超级父接口：java.util.Collection;</span><br><span class="line"></span><br><span class="line">一类是以键值对（kay and value）的方式存储元素</span><br><span class="line">	以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="集合继承图（重点！）"><a href="#集合继承图（重点！）" class="headerlink" title="集合继承图（重点！）"></a>集合继承图（重点！）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集合拥有着一大系列的关系，下面的图为我们展现了常用集合的关系</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200817185126139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020081718514028.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要知道的是，并非仅仅只有图中的集合，只列出了常用的集合类型。</span><br><span class="line">具体查询API即可。</span><br><span class="line">要很熟悉该图，知道哪些是接口，哪些是类。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collection是一部分集合的父类接口，也就是说在Collection中的方法</span><br><span class="line">都能在其子类中去找到并完成实现。所以非常重要，这涉及到集合的操作。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Collection接口中常用方法"><a href="#Collection接口中常用方法" class="headerlink" title="Collection接口中常用方法"></a>Collection接口中常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于java.util.Collection接口中常用的方法。</span><br><span class="line">    <span class="number">1</span>、Collection中能存放什么元素？</span><br><span class="line">        没有使用“泛型”之前，Collection中可以存储Object的所有子类型。</span><br><span class="line">        使用了“泛型”之后，Collection中只能存储某个具体的类型。</span><br><span class="line">        集合后期我们会学习“泛型”语法。目前先不用管。Collection中什么都能存，</span><br><span class="line">        只要是Object的子类型就行。（集合中不能直接存储基本数据类型，也不能存</span><br><span class="line">        java对象，只是存储java对象的内存地址。）</span><br><span class="line">    <span class="number">2</span>、Collection中的常用方法</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object e)</span> 向集合中添加元素</span></span><br><span class="line"><span class="function">        <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>  获取集合中元素的个数</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> 清空集合</span></span><br><span class="line"><span class="function">        <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> 判断当前集合中是否包含元素o，包含返回<span class="keyword">true</span>，不包含返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function">        <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> 删除集合中的某个元素。</span></span><br><span class="line"><span class="function">        <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>  判断该集合中元素的个数是否为0</span></span><br><span class="line"><span class="function">        Object[] <span class="title">toArray</span><span class="params">()</span>  调用这个方法可以把集合转换成数组。【作为了解，使用不多。】</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">具体的代码试验如下：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">创建一个集合对象</span><br><span class="line"></span><br><span class="line">	错误！Collection c = <span class="keyword">new</span> Collection();</span><br><span class="line">	接口是抽象的，无法实例化。</span><br><span class="line">	</span><br><span class="line">应该用多态</span><br><span class="line">	Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	</span><br><span class="line">测试Collection接口中的常用方法</span><br><span class="line"></span><br><span class="line">	c.add(<span class="number">1200</span>); </span><br><span class="line">	</span><br><span class="line">	为什么能直接写<span class="number">1200</span>？因为自动装箱(java5的新特性。)</span><br><span class="line">	实际上是放进去了一个对象的内存地址。</span><br><span class="line">	类似于</span><br><span class="line">	Integer x = <span class="keyword">new</span> Integer(<span class="number">1200</span>);</span><br><span class="line">	c.add(x);</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line"> 	c.add(<span class="number">3.14</span>); <span class="comment">// 自动装箱</span></span><br><span class="line">	c.add(<span class="keyword">new</span> Object());</span><br><span class="line">	c.add(<span class="keyword">new</span> Student());</span><br><span class="line">	c.add(<span class="keyword">true</span>); <span class="comment">// 自动装箱</span></span><br><span class="line"></span><br><span class="line">获取集合中元素的个数</span><br><span class="line">	System.out.println(<span class="string">&quot;集合中元素个数是：&quot;</span> + c.size()); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">清空集合</span><br><span class="line">	c.clear();</span><br><span class="line">	System.out.println(<span class="string">&quot;集合中元素个数是：&quot;</span> + c.size()); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">再向集合中添加元素</span><br><span class="line">	c.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// &quot;hello&quot;对象的内存地址放到了集合当中。</span></span><br><span class="line">	c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">	c.add(<span class="string">&quot;浩克&quot;</span>);</span><br><span class="line">	c.add(<span class="string">&quot;绿巨人&quot;</span>);</span><br><span class="line">	c.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">判断集合中是否包含<span class="string">&quot;绿巨人&quot;</span></span><br><span class="line">	<span class="keyword">boolean</span> flag = c.contains(<span class="string">&quot;绿巨人&quot;</span>);</span><br><span class="line">	System.out.println(flag); <span class="comment">// true</span></span><br><span class="line">	<span class="keyword">boolean</span> flag2 = c.contains(<span class="string">&quot;绿巨人2&quot;</span>);</span><br><span class="line">	System.out.println(flag2); <span class="comment">// false</span></span><br><span class="line">	System.out.println(c.contains(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;集合中元素个数是：&quot;</span> + c.size()); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">删除集合中某个元素</span><br><span class="line">	c.remove(<span class="number">1</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;集合中元素个数是：&quot;</span> + c.size()); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">判断集合是否为空（集合中是否存在元素）</span><br><span class="line">	System.out.println(c.isEmpty());</span><br><span class="line">	<span class="keyword">false</span></span><br><span class="line">	</span><br><span class="line">    清空</span><br><span class="line">	c.clear();</span><br><span class="line">	System.out.println(c.isEmpty());</span><br><span class="line">	<span class="keyword">true</span>（<span class="keyword">true</span>表示集合中没有元素了！）</span><br><span class="line">	</span><br><span class="line">转换成数组（了解，使用不多。）</span><br><span class="line">	Object[] objs = c.toArray();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objs.length; i++)&#123;</span><br><span class="line">		遍历数组</span><br><span class="line">		Object o = objs[i];</span><br><span class="line">		System.out.println(o);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="深入Collection集合的contains方法"><a href="#深入Collection集合的contains方法" class="headerlink" title="深入Collection集合的contains方法"></a>深入Collection集合的contains方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean contains(Object o)</span><br><span class="line">判断集合中是否包含某个对象o</span><br><span class="line">如果包含返回true， 如果不包含返回false。</span><br><span class="line"></span><br><span class="line">contains方法是用来判断集合中是否包含某个元素的方法，</span><br><span class="line">那么它在底层是怎么判断集合中是否包含某个元素的呢？</span><br><span class="line">调用了equals方法进行比对。</span><br><span class="line">equals方法返回true，就表示包含这个元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	创建集合对象</span><br><span class="line">	Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">	向集合中存储元素</span><br><span class="line">	String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">// s1 = 0x1111</span></span><br><span class="line">	c.add(s1); <span class="comment">// 放进去了一个&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">	String s2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>); <span class="comment">// s2 = 0x2222</span></span><br><span class="line">	c.add(s2);</span><br><span class="line"></span><br><span class="line">	集合中元素的个数</span><br><span class="line">	System.out.println(<span class="string">&quot;元素的个数是：&quot;</span> + c.size()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">	新建的对象String但是不存入集合中</span><br><span class="line">	String x = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">// x = 0x5555</span></span><br><span class="line">	c集合中是否包含x？结果猜测一下是<span class="keyword">true</span>还是<span class="keyword">false</span>？</span><br><span class="line">	System.out.println(c.contains(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般来说，c和x是两个引用，他们存储的内存地址是不一样的。</span><br><span class="line"></span><br><span class="line">但是由于contains方法底层其实调用了equals方法，所以会在此时调用。</span><br><span class="line"></span><br><span class="line">而c和x是两个String类型的引用，equals被重写了，所以c和x在equals方法下是相等的！</span><br><span class="line"></span><br><span class="line">所以c.contains(x)是true！</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="深入Collection集合的remove方法"><a href="#深入Collection集合的remove方法" class="headerlink" title="深入Collection集合的remove方法"></a>深入Collection集合的remove方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean remove(Object o) 删除集合中的某个元素。</span><br><span class="line">其实他的底层也调用了equals方法去判断。</span><br><span class="line">通过类的equals方法去比对传的参数o和集合中的元素是否相等，从而判断是否要删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	创建集合对象</span><br><span class="line">	Collection cc = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	</span><br><span class="line">	创建字符串对象</span><br><span class="line">	String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	加进去。</span><br><span class="line">	cc.add(s1);</span><br><span class="line"></span><br><span class="line">	创建了一个新的字符串对象</span><br><span class="line">	String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	删除s2</span><br><span class="line">	cc.remove(s2); </span><br><span class="line">	s1.equals(s2) java认为s1和s2是一样的。删除s2就是删除s1。</span><br><span class="line">	</span><br><span class="line">	集合中元素个数是？</span><br><span class="line">	System.out.println(cc.size()); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存放在一个集合中的类型，一定要重写equals方法！！！</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="集合遍历-迭代（重点-）"><a href="#集合遍历-迭代（重点-）" class="headerlink" title="集合遍历/迭代（重点!）"></a>集合遍历/迭代（重点!）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先我们可以在API中发现，Collection接口其实还继承了一个接口：</span><br><span class="line">Iterable</span><br><span class="line">这个接口提供了一个方法</span><br><span class="line">iterator() </span><br><span class="line">返回类型为 Iterator 迭代器。 </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下面通过实例来了解迭代器</span><br><span class="line">注意：以下讲解的遍历方式/迭代方式，是所有Collection通用的一种方式。</span><br><span class="line">在Map集合中不能用。在所有的Collection以及子类中使用。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	创建集合对象</span><br><span class="line">	后面的集合无所谓，主要是看前面的Collection接口，怎么遍历/迭代。</span><br><span class="line">	Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	</span><br><span class="line">	添加元素</span><br><span class="line">	c.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	c.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">	c.add(<span class="number">100</span>);</span><br><span class="line">	c.add(<span class="keyword">new</span> Object());</span><br><span class="line">	</span><br><span class="line">	对集合Collection进行遍历/迭代</span><br><span class="line">	第一步：获取集合对象的迭代器对象Iterator</span><br><span class="line">	Iterator it = c.iterator();</span><br><span class="line">	</span><br><span class="line">	第二步：通过以上获取的迭代器对象开始迭代/遍历集合。</span><br><span class="line">		以下两个方法是迭代器对象Iterator中的方法：</span><br><span class="line">			<span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span>如果仍有元素可以迭代，则返回 <span class="keyword">true</span>。</span></span><br><span class="line"><span class="function">			Object <span class="title">next</span><span class="params">()</span> 返回迭代的下一个元素。</span></span><br><span class="line"><span class="function">			</span></span><br><span class="line"><span class="function">	<span class="title">while</span><span class="params">(it.hasNext()</span>)</span>&#123;</span><br><span class="line">		Object obj = it.next();</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">abc</span><br><span class="line">def</span><br><span class="line"><span class="number">100</span></span><br><span class="line">java.lang.Object@<span class="number">10f</span>87f48</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前面我们提到</span><br><span class="line">List集合存储元素特点：有序可重复</span><br><span class="line">Set集合存储元素特点：无序不可重复。</span><br><span class="line">下面通过迭代器来对其进行探究</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	创建集合对象</span><br><span class="line">	Collection c1  = <span class="keyword">new</span> ArrayList(); <span class="comment">// ArrayList集合：有序可重复</span></span><br><span class="line">	</span><br><span class="line">	添加元素</span><br><span class="line">	c1.add(<span class="number">1</span>);</span><br><span class="line">	c1.add(<span class="number">2</span>);</span><br><span class="line">	c1.add(<span class="number">3</span>);</span><br><span class="line">	c1.add(<span class="number">4</span>);</span><br><span class="line">	c1.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	迭代集合</span><br><span class="line">	Iterator it = c1.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		存进去是什么类型，取出来还是什么类型。</span><br><span class="line">		Object obj = it.next();</span><br><span class="line">		只不过在输出的时候会转换成字符串。因为这里println会调用toString()方法。</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HashSet集合：无序不可重复</span><br><span class="line">	Collection c2 = <span class="keyword">new</span> HashSet();</span><br><span class="line">	</span><br><span class="line">	无序：存进去和取出的顺序不一定相同。</span><br><span class="line">	不可重复：存储<span class="number">100</span>，不能再存储<span class="number">100.</span></span><br><span class="line">	c2.add(<span class="number">100</span>);</span><br><span class="line">	c2.add(<span class="number">200</span>);</span><br><span class="line">	c2.add(<span class="number">300</span>);</span><br><span class="line">	c2.add(<span class="number">90</span>);</span><br><span class="line">	c2.add(<span class="number">400</span>);</span><br><span class="line">	c2.add(<span class="number">50</span>);</span><br><span class="line">	c2.add(<span class="number">60</span>);</span><br><span class="line">	c2.add(<span class="number">100</span>);</span><br><span class="line">	Iterator it2 = c2.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">		System.out.println(it2.next());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过观察输出我们可以发现</span><br><span class="line">对于List集合，存进去是什么顺序，迭代输出也是什么顺序。</span><br><span class="line">而对于Set集合，存入的顺序无法决定输出的顺序，每次输出的顺序是无序，乱的</span><br><span class="line">而且对于重复的元素，只会输出一次，说明重复的元素无法存入。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关于迭代器的更新"><a href="#关于迭代器的更新" class="headerlink" title="关于迭代器的更新"></a>关于迭代器的更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一定要注意：集合结构只要发生改变，迭代器必须重新获取。</span><br><span class="line"></span><br><span class="line">当集合结构发生了改变，迭代器没有重新获取时，调用next()方法时：</span><br><span class="line"></span><br><span class="line">java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建集合</span><br><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">注意：此时获取的迭代器，指向的是那是集合中没有元素状态下的迭代器。</span><br><span class="line">一定要注意：集合结构只要发生改变，迭代器必须重新获取。</span><br><span class="line">当集合结构发生了改变，迭代器没有重新获取时，调用next()方法时：</span><br><span class="line">java.util.ConcurrentModificationException</span><br><span class="line"></span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line"></span><br><span class="line">添加元素（在获取了迭代器之后更新的话）</span><br><span class="line">c.add(<span class="number">1</span>); <span class="comment">// Integer类型</span></span><br><span class="line">c.add(<span class="number">2</span>);</span><br><span class="line">c.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">利用迭代器迭代</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	Object obj = it.next();</span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">此时就会出现错误！</span><br><span class="line">因为当集合结构发生了改变，迭代器没有重新获取时，调用next()方法时：</span><br><span class="line">java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="迭代器的remove方法"><a href="#迭代器的remove方法" class="headerlink" title="迭代器的remove方法"></a>迭代器的remove方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在迭代集合元素的过程中，不能调用集合对象的remove方法，删除元素：c.remove(o); 迭代过程中不能这样。</span><br><span class="line">会出现：java.util.ConcurrentModificationException</span><br><span class="line"></span><br><span class="line">在迭代元素的过程当中，一定要使用迭代器Iterator的remove方法，删除元素，</span><br><span class="line">不要使用集合自带的remove方法删除元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c2.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">c2.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">c2.add(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator it2 = c2.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">	Object o = it2.next();</span><br><span class="line">	</span><br><span class="line">	删除元素</span><br><span class="line">	删除元素之后，集合的结构发生了变化，应该重新去获取迭代器</span><br><span class="line">	但是，循环下一次的时候并没有重新获取迭代器</span><br><span class="line">	所以会出现异常：java.util.ConcurrentModificationException</span><br><span class="line">	出异常根本原因是：集合中元素删除了，但是没有更新迭代器（迭代器不知道集合变化了）</span><br><span class="line">	c2.remove(o);</span><br><span class="line">	直接通过集合去删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同。）</span><br><span class="line">	</span><br><span class="line">	使用迭代器来删除可以吗？</span><br><span class="line">	迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素）。</span><br><span class="line">	it2.remove();</span><br><span class="line">	删除的一定是迭代器指向的当前元素。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记19-（集合②）</title>
    <url>/2020/08/17/java_study_19/</url>
    <content><![CDATA[<p>JAVA学习笔记19-（集合②）</p>
<a id="more"></a>



<hr>
<h1 id="集合②"><a href="#集合②" class="headerlink" title="集合②"></a>集合②</h1><blockquote>
<p>List接口</p>
<blockquote>
<p>ArrayList<br>LinkedList<br>Vector</p>
</blockquote>
<p>泛型<br>foreach</p>
</blockquote>
<hr>
<h2 id="List接口常用方法"><a href="#List接口常用方法" class="headerlink" title="List接口常用方法"></a>List接口常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、List集合存储元素特点：有序可重复</span><br><span class="line">有序：List集合中的元素有下标。从0开始，以1递增。</span><br><span class="line">重复：存储一个1，还可以再存储1。</span><br><span class="line">2、List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法：</span><br><span class="line">	以下只列出List接口特有的常用的方法：</span><br><span class="line">		void add(int index, Object element)</span><br><span class="line">		Object set(int index, Object element)</span><br><span class="line">		Object get(int index)</span><br><span class="line">		int indexOf(Object o)</span><br><span class="line">		int lastIndexOf(Object o)</span><br><span class="line">		Object remove(int index)</span><br><span class="line"></span><br><span class="line">以上几个方法不需要死记硬背，可以自己编写代码测试一下，理解一下，以后开发的时候，还是要翻阅帮助文档。</span><br></pre></td></tr></table></figure>
<p>API链接: <a href="https://www.apiref.com/java11-zh/index.html">JDK11版本</a>.<br>API链接: <a href="https://www.matools.com/api/java8">JDK8版本</a>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于List接口常用方法的代码演示：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        创建List类型的集合。</span><br><span class="line">        List myList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        List myList = <span class="keyword">new</span> Vector();</span><br><span class="line">        List myList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        添加元素</span><br><span class="line">        默认都是向集合末尾添加元素。</span><br><span class="line">        myList.add(<span class="string">&quot;A&quot;</span>); </span><br><span class="line">        myList.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        myList.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        myList.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        myList.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"></span><br><span class="line">        在列表的指定位置插入指定元素（第一个参数是下标）</span><br><span class="line">        这个方法对于ArrayList集合来说效率比较低。</span><br><span class="line">        因为每次插入都会导致后续的所有元素后移一位。</span><br><span class="line">        对于LinkedList效率可以。（链表特性）</span><br><span class="line">        myList.add(<span class="number">1</span>, <span class="string">&quot;KING&quot;</span>);</span><br><span class="line"></span><br><span class="line">        迭代</span><br><span class="line">        Iterator it = myList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Object elt = it.next();</span><br><span class="line">            System.out.println(elt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        根据下标获取元素</span><br><span class="line">        Object firstObj = myList.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(firstObj);</span><br><span class="line"></span><br><span class="line">        因为有下标，所以List集合有自己比较特殊的遍历方式</span><br><span class="line">        通过下标遍历。【List集合特有的方式，Set没有。】</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.size(); i++)&#123;</span><br><span class="line">            Object obj = myList.get(i);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        获取指定对象第一次出现处的索引。</span><br><span class="line">        System.out.println(myList.indexOf(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        获取指定对象最后一次出现处的索引。</span><br><span class="line">        System.out.println(myList.lastIndexOf(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        删除指定下标位置的元素</span><br><span class="line">        删除下标为<span class="number">0</span>的元素</span><br><span class="line">        myList.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(myList.size()); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        修改指定位置的元素</span><br><span class="line">        myList.set(<span class="number">2</span>, <span class="string">&quot;Soft&quot;</span>);</span><br><span class="line"></span><br><span class="line">        遍历集合</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.size(); i++)&#123;</span><br><span class="line">            Object obj = myList.get(i);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList集合总结：</span><br><span class="line"></span><br><span class="line">ArrayList集合：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>、默认初始化容量<span class="number">10</span>（底层先创建了一个长度为<span class="number">0</span>的数组，当添加第一个元素的时候，初始化容量<span class="number">10</span>。）</span><br><span class="line">    </span><br><span class="line">    <span class="number">2</span>、集合底层是一个Object[]数组。</span><br><span class="line">    </span><br><span class="line">    <span class="number">3</span>、构造方法：</span><br><span class="line">        <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">new</span> ArrayList(<span class="number">20</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="number">4</span>、ArrayList集合的扩容：</span><br><span class="line">        增长到原容量的<span class="number">1.5</span>倍。</span><br><span class="line">        ArrayList集合底层是数组，怎么优化？</span><br><span class="line">            尽可能少的扩容。</span><br><span class="line">            因为数组扩容效率比较低，建议在使用ArrayList集合的时候预估计元素的个数，给定一个初始化容量。</span><br><span class="line">            </span><br><span class="line">    <span class="number">5</span>、数组优点：</span><br><span class="line">        检索效率比较高。</span><br><span class="line">        （每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址，然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。）</span><br><span class="line">        </span><br><span class="line">    <span class="number">6</span>、数组缺点：</span><br><span class="line">        随机增删元素效率比较低。</span><br><span class="line">        另外数组无法存储大数据量。（很难找到一块非常巨大的连续的内存空间。）</span><br><span class="line">        </span><br><span class="line">    <span class="number">7</span>、向数组末尾添加元素，效率很高，不受影响。</span><br><span class="line">    </span><br><span class="line">    <span class="number">8</span>、面试官经常问的一个问题？</span><br><span class="line">        这么多的集合中，你用哪个集合最多？</span><br><span class="line">            答：ArrayList集合。</span><br><span class="line">            因为往数组末尾添加元素，效率不受影响。</span><br><span class="line">            另外，我们检索/查找某个元素的操作比较多。</span><br><span class="line"></span><br><span class="line">    <span class="number">9</span>、ArrayList集合是非线程安全的。（不是线程安全的集合。）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList集合在满了的时候是自动扩容的，且每次扩容的大小是前一次的1.5倍</span><br><span class="line">例如第一次的大小为4，那么第二次就是4*1.5&#x3D;6。这是由于他在底层代码中使用了位运算。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于ArrayList的构造方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        默认初始化容量<span class="number">10</span></span><br><span class="line">        List myList1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        指定初始化容量<span class="number">100</span></span><br><span class="line">        List myList2 = <span class="keyword">new</span> ArrayList(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        创建一个HashSet集合</span><br><span class="line">        Collection c = <span class="keyword">new</span> HashSet();</span><br><span class="line">        </span><br><span class="line">        添加元素到Set集合</span><br><span class="line">        c.add(<span class="number">100</span>);</span><br><span class="line">        c.add(<span class="number">200</span>);</span><br><span class="line">        c.add(<span class="number">900</span>);</span><br><span class="line">        c.add(<span class="number">50</span>);</span><br><span class="line">        c.add(<span class="number">350</span>);</span><br><span class="line">        c.add(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">        通过这个构造方法就可以将HashSet集合转换成List集合。</span><br><span class="line">        List myList3 = <span class="keyword">new</span> ArrayList(c);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList3.size(); i++)&#123;</span><br><span class="line">            System.out.println(myList3.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &gt;&gt; <span class="number">1</span> 二进制右移<span class="number">1</span>位。</span><br><span class="line">        &gt;&gt; <span class="number">2</span> 二进制右移<span class="number">2</span>位。</span><br><span class="line">        <span class="number">10</span>的二进制位是：<span class="number">00001010</span>  【<span class="number">10</span>】</span><br><span class="line">        <span class="number">10</span>的二进制右移<span class="number">1</span>位是：<span class="number">00000101</span>  【<span class="number">5</span>】</span><br><span class="line">        System.out.println(<span class="number">10</span> &gt;&gt; <span class="number">1</span>); </span><br><span class="line">        右移<span class="number">1</span>位就是除以<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        二进制位左移<span class="number">1</span>位</span><br><span class="line">        <span class="number">10</span>的二进制位是：<span class="number">00001010</span>  【<span class="number">10</span>】</span><br><span class="line">        <span class="number">10</span>的二进制左移<span class="number">1</span>位：<span class="number">00010100</span> 【<span class="number">20</span>】</span><br><span class="line">        System.out.println(<span class="number">10</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList总结：</span><br><span class="line"></span><br><span class="line">LinkList创建的集合是一个双向链表！</span><br><span class="line"></span><br><span class="line">LinkedList集合没有初始化容量。</span><br><span class="line"></span><br><span class="line">链表的优点：</span><br><span class="line">    由于链表上的元素在空间存储上内存地址不连续。</span><br><span class="line">    所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。</span><br><span class="line">    在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议使用LinkedList。</span><br><span class="line"></span><br><span class="line">链表的缺点：</span><br><span class="line">    不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，直到找到为止。</span><br><span class="line">    所以LinkedList集合检索/查找的效率较低。</span><br><span class="line"></span><br><span class="line">ArrayList：把检索发挥到极致。（末尾添加元素效率还是很高的。）</span><br><span class="line">LinkedList：把随机增删发挥到极致。</span><br><span class="line"></span><br><span class="line">加元素都是往末尾添加，所以ArrayList用的比LinkedList多。</span><br><span class="line"></span><br><span class="line">具体的各种方法前往API查阅即可。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector总结：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、底层也是一个数组。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、初始化容量：<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、扩容之后是原容量的<span class="number">2</span>倍。</span><br><span class="line">	<span class="number">10</span>--&gt; <span class="number">20</span> --&gt; <span class="number">40</span> --&gt; <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、ArrayList集合扩容特点：</span><br><span class="line">	ArrayList集合扩容是原容量<span class="number">1.5</span>倍。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、Vector中所有的方法都是线程同步的，都带有<span class="keyword">synchronized</span>关键字，是线程安全的。</span><br><span class="line">但是效率比较低，使用较少了。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、JDK5.0之后推出的新特性：泛型</span><br><span class="line">2、泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。（运行阶段泛型没用！）</span><br><span class="line">3、使用了泛型好处是什么？</span><br><span class="line">    第一：集合中存储的元素类型统一了。</span><br><span class="line">    第二：从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”！</span><br><span class="line"></span><br><span class="line">4、泛型的缺点是什么？</span><br><span class="line">    导致集合中存储的元素缺乏多样性！</span><br><span class="line">    大多数业务中，集合中元素的类型还是统一的。所以这种泛型特性被大家所认可。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">为了探究泛型的作用，我们首先来创建以下的几个类：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    父类自带方法</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在移动！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    特有方法</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    特有方法</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟儿在飞翔！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">泛型到底能干啥？首先来看一段没有使用泛型的代码，并分析其缺点：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	不使用泛型机制，分析程序存在缺点</span><br><span class="line"></span><br><span class="line">	List myList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">	准备对象</span><br><span class="line">	Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">	Bird b = <span class="keyword">new</span> Bird();</span><br><span class="line"></span><br><span class="line">	将对象添加到集合当中</span><br><span class="line">	myList.add(c);</span><br><span class="line">	myList.add(b);</span><br><span class="line"></span><br><span class="line">	遍历集合，取出每个Animal，让它move</span><br><span class="line">	Iterator it = myList.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">	</span><br><span class="line">		没有这个语法，通过迭代器取出的就是Object</span><br><span class="line">		Animal a = it.next();</span><br><span class="line"></span><br><span class="line">		只能这样写：（因为迭代器取出来的就是Object）</span><br><span class="line">		Object obj = it.next();</span><br><span class="line">		</span><br><span class="line"> 		obj中没有move方法，无法调用，需要向下转型！</span><br><span class="line">		<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Animal)&#123;</span><br><span class="line">			Animal a = (Animal)obj;</span><br><span class="line">			a.move();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以看到，在没有使用泛型时，程序必须通过向下转型的方式才能去调用Animal中的方法。</span><br><span class="line"></span><br><span class="line">然而我们集合中如果只存了Animal类的话，我们希望是能够直接调用！而不是去麻烦的转型！</span><br><span class="line"></span><br><span class="line">往往在实际的开发中我们也都希望一个集合中只有同一个类型的数据，这样在迭代器获取时就不会将他默认归为Object类，从而无法调用特定方法了。</span><br><span class="line"></span><br><span class="line">那么这个时候就需要我们去使用  泛型  来统一集合中的数据类型，从而简化代码。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下面的代码使用了泛型后：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	使用JDK5之后的泛型机制</span><br><span class="line">	使用泛型List&lt;Animal&gt;之后，表示List集合中只允许存储Animal类型的数据。</span><br><span class="line">	用泛型来指定集合中存储的数据类型。</span><br><span class="line">	List&lt;Animal&gt; myList = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">	指定List集合中只能存储Animal，那么存储String就编译报错了。</span><br><span class="line">	这样用了泛型之后，集合中元素的数据类型更加统一了。</span><br><span class="line">	错误：myList.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">	Bird b = <span class="keyword">new</span> Bird();</span><br><span class="line"></span><br><span class="line">	myList.add(c);</span><br><span class="line">	myList.add(b);</span><br><span class="line"></span><br><span class="line">	获取迭代器</span><br><span class="line">	这个表示迭代器迭代的是Animal类型。</span><br><span class="line">	Iterator&lt;Animal&gt; it = myList.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		使用泛型之后，每一次迭代返回的数据都是Animal类型。</span><br><span class="line">		Animal a = it.next();</span><br><span class="line">		这里不需要进行强制类型转换了。直接调用。</span><br><span class="line">		a.move();</span><br><span class="line"></span><br><span class="line">		当然调用子类型特有的方法还是需要向下转换的！</span><br><span class="line">		Animal a = it.next();</span><br><span class="line">		<span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">			Cat x = (Cat)a;</span><br><span class="line">			x.catchMouse();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">			Bird y = (Bird)a;</span><br><span class="line">			y.fly();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自动类型推断机制（钻石表达式）"><a href="#自动类型推断机制（钻石表达式）" class="headerlink" title="自动类型推断机制（钻石表达式）"></a>自动类型推断机制（钻石表达式）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;这里的类型会自动推断&gt;()，前提是JDK8之后才允许。</span><br><span class="line">自动类型推断，钻石表达式！</span><br><span class="line">List&lt;Animal&gt; myList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">与前面未使用自动类型推断机制比较：</span><br><span class="line">List&lt;Animal&gt; myList = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">简化了代码。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自定义泛型的时候，&lt;&gt; 尖括号中的是一个标识符，随便写。</span><br><span class="line"></span><br><span class="line">java源代码中经常出现的是：</span><br><span class="line">&lt;E&gt;和&lt;T&gt;</span><br><span class="line"></span><br><span class="line">E是Element单词首字母。</span><br><span class="line">T是Type单词首字母。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest03</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">(E o)</span></span>&#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span>对象的时候指定了泛型是：String类型</span><br><span class="line">        GenericTest03&lt;String&gt; gt = <span class="keyword">new</span> GenericTest03&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        类型不匹配</span><br><span class="line">        错误：gt.doSome(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        gt.doSome(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样就可以在自己写的各种方法，类中去使用泛型了。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="foreach（增强for循环）"><a href="#foreach（增强for循环）" class="headerlink" title="foreach（增强for循环）"></a>foreach（增强for循环）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK5.<span class="number">0</span>之后推出了一个新特性：叫做增强<span class="keyword">for</span>循环，或者叫做foreach</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>类型数组</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">432</span>,<span class="number">4</span>,<span class="number">65</span>,<span class="number">46</span>,<span class="number">54</span>,<span class="number">76</span>,<span class="number">54</span>&#125;;</span><br><span class="line"></span><br><span class="line">        遍历数组（普通<span class="keyword">for</span>循环）</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        增强<span class="keyword">for</span>（foreach）</span><br><span class="line">        以下是语法</span><br><span class="line">        <span class="keyword">for</span>(元素类型 变量名 : 数组或集合)&#123;</span><br><span class="line">            System.out.println(变量名);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">        foreach有一个缺点：没有下标。在需要使用下标的循环中，不建议使用增强<span class="keyword">for</span>循环。</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> data : arr) &#123;</span><br><span class="line">            data就是数组中的元素（数组中的每一个元素。）</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">同理集合也可以用，不再演示。</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记-2</title>
    <url>/2020/07/31/java_study_2/</url>
    <content><![CDATA[<p>Day2，keep！</p>
<a id="more"></a>

<hr>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装，指的是对一个类进行包装封闭，使内部的数据安全，不会被随意修改访问。就像电视机和遥控器，电视机是一个非常复杂的器件，但是我们只需要用遥控器进行简单的操作就能完成对电视机的控制，对于用户来说，他们的使用方便快捷易懂，不易出错，体验好；对于开发者来说，封装保证了自己程序内部的安全，不易被修改，也保证了产品的稳定性。</p>
<p>如何封装？首先要将类中的属性设为私有化<br><strong>封装的第一步：关键字  private</strong><br>private 表示私有的，被这个关键字修饰之后，该数据只能在本类中访问。<br>出了这个类，属性就无法访问了。私有的。<br>例如，定义一个类  人类Person</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 每一个人年龄值不同，对象级别的属性。</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>这样age 就是一个私有变量，仅在Person类中允许被访问，在外部访问是无法做到的。<br> 但是这样又未免太过安全，使得age成了无用之物。这时就得需要接口方法<br> 接口方法分为读数据(get)和写数据(set)方法，他们来完成对类中私有变量的读取和更改写入</p>
<p>get读年龄，set改年龄，这个读和改都是操作的一个对象的年龄。（没有对象何来年龄）<br><strong>封装的第二步：对外提供公开的set方法和get方法作为操作入口。并且都不带static。都是实例方法。</strong><br>下为实例方法的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名(形式参数列表) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get方法，只需return age变量即可完成对age的读取；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set方法，通过传参去修改age变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> nianLing)</span></span>&#123;</span><br><span class="line">	age = nianLing;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">**注意：</span><br><span class="line">	java开发规范中有要求，set方法和get方法要满足以下格式 </span><br><span class="line">   get方法的要求：</span><br><span class="line">        <span class="keyword">public</span> 返回值类型 get+属性名首字母大写(无参)&#123;</span><br><span class="line">    			  <span class="keyword">return</span> xxx;</span><br><span class="line">     &#125;		</span><br><span class="line">    		 </span><br><span class="line">**set方法的要求：</span><br><span class="line">     	<span class="keyword">public</span> <span class="keyword">void</span> set+属性名首字母大写(有<span class="number">1</span>个参数)&#123;</span><br><span class="line">     			 xxx = 参数;</span><br><span class="line">     &#125;**</span><br></pre></td></tr></table></figure>

<p>一般来说，在set方法都会去加上限制条件来判断输入是否合法，从而去避免对数据的乱改而造成破坏。<br>对于age来说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> nianLing)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 在这个位置上设置关卡</span></span><br><span class="line">  <span class="keyword">if</span>(nianLing &lt; <span class="number">0</span> || nianLing &gt; <span class="number">150</span>)&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;对不起，年龄值不合法，请重新赋值！&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span>; <span class="comment">//直接终止程序的执行。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//程序能够执行到这里，说明年龄一定是合法的。</span></span><br><span class="line">  age = nianLing;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="空指针异常NullPointerException"><a href="#空指针异常NullPointerException" class="headerlink" title="空指针异常NullPointerException"></a>空指针异常NullPointerException</h2><p>出现空指针异常的前提条件是？<br>      “空引用”访问实例【对象相关】相关的数据时，都会出现空指针异常。<br>  空指针异常导致的最本质的原因是？<br>       空引用访问“实例相关的数据”，会出现空指针异常。<br>        实例相关的包括：实例变量 + 实例方法。</p>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记-3</title>
    <url>/2020/08/01/java_study_3/</url>
    <content><![CDATA[<p>Day3，keep！</p>
<a id="more"></a>

<hr>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>1、static翻译为“静态<br>2、所有static关键字修饰的都是类相关的，类级别的。<br>3、所有static修饰的，都是采用“类名.”的方式访问<br>4、static修饰的变量：静态变量<br>5、static修饰的方法：静态方法</p>
<hr>
<h2 id="变量的分类："><a href="#变量的分类：" class="headerlink" title="变量的分类："></a>变量的分类：</h2><pre><code>变量根据声明的位置进行划分：
    在方法体当中声明的变量叫做：局部变量。
    在方法体外声明的变量叫做：成员变量。</code></pre>
<p>成员变量又可以分为：实例变量和静态变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> idNumber;<span class="comment">//实例变量，**对象级别的变量**，也就是说必须要通过&quot;引用.&quot;的方式去访问，是每个对象都独有（**且值不一定一样**）的属性。</span></span><br><span class="line"><span class="keyword">static</span> String country;<span class="comment">//静态变量，**类级别的变量**，也就是说访问通过&quot;类.&quot;的方式，是类中每个对象共同拥有**且值一样**的属性。</span></span><br><span class="line"></span><br><span class="line">在此 Chinese 类中，idNumber是每个对象都有且不一样的，所以是对象级别的数据，定义为实例变量；然而country是每个Chinese中对象共同拥有且值一样的对象，（都是<span class="string">&quot;中国&quot;</span>），如果将其定义为实例变量会造成内存的浪费，不必要。所以定为静态变量 <span class="keyword">static</span> String country</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>静态变量在类加载时初始化，不需要new对象，静态变量的空间就开出来了。</strong><br><strong>静态变量存储在方法区。</strong><br>至于JAVA的内存结构，将在下一篇讲述。</p>
<p>空指针异常只有在什么情况下才会发生呢?<br>只有在“空引用”访问“实例”相关的，都会出现空指针异常。</p>
<p>如何访问？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问实例变量，需要通过对象去访问，如</span></span><br><span class="line">Chinese c1  = <span class="keyword">new</span> Chinese();</span><br><span class="line">c1.idNumber;</span><br><span class="line"><span class="comment">//访问静态变量，则直接通过类去访问</span></span><br><span class="line">Chinese.country;</span><br></pre></td></tr></table></figure>

<p>同样，在类中也就有了  实例方法和静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实例方法是</span><br><span class="line">[修饰符列表] [返回值内型] 方法名(参数列表)&#123;&#125;</span><br><span class="line">实例方法（实例相关的都需要<span class="keyword">new</span>对象，使用<span class="string">&quot;引用.&quot;</span>来访问。）</span><br><span class="line"></span><br><span class="line">静态方法是</span><br><span class="line">[修饰符列表] <span class="keyword">static</span> [返回值内型] 方法名(参数列表)&#123;&#125;</span><br><span class="line"><span class="comment">// 静态方法（静态方法不需要new对象，直接使用“类名.”来访问）</span></span><br><span class="line"><span class="comment">// 但是也可以使用“引用.”来访问，不建议用。（因为其他程序员会感到困惑。）</span></span><br></pre></td></tr></table></figure>

<p>如何判断是使用实例方法还是静态方法？<br><strong>当这个方法体当中，直接访问了实例变量，这个方法一定是实例方法。</strong></p>
<hr>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>使用static关键字可以定义：静态代码块<br>语法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   java语句;</span><br><span class="line">   java语句;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>static静态代码块在类加载时执行。并且只执行一次。</strong><br><strong>也就是说静态代码块在main方法执行之前执行。</strong><br><strong>且静态代码块一般是按照自上而下的顺序执行。</strong></p>
<p>静态代码块一般在类加载时期使用，具体作用暂时未接触···<br>也许公司开发需要记录等会用到吧</p>
<hr>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">//这个i就是静态变量，他储存在方法区，类加载时初始化。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>1、this是一个关键字，全部小写。<br>2、一个对象一个this，是一个变量，是一个引用，<strong>保存了当前对象的内存地址，指向自身。this代表的就是“当前对象”，this存储在堆内存当中对象的内部。</strong><br>3、<strong>this只能使用在实例方法中。</strong>谁调用这个实例方法，this就是谁。<br>4、“this.”大部分情况下是可以省略的。<br>5、<strong>this不能使用在静态方法中</strong>，this表示当前对象，是对象级别的，然而静态方法则是类级别的，里面没有当前对象。</p>
<p>this关键字大部分情况下可以省略，什么时候不能省略呢？<br><strong>在实例方法中，或者构造方法中，为了区分局部变量和实例变量，</strong><br><strong>这种情况下：this. 是不能省略的。</strong><br>主要是为了增强代码可读性。<br>例如有一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Studnet</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我提供2个构造方法（无参和有参）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> a,String b)</span></span>&#123;</span><br><span class="line">	id = a;</span><br><span class="line">	name = b;</span><br><span class="line">	<span class="comment">//上述代码的确可以执行，完全没问题，但是参数中的a和b是不符合命名规范的，然而如果改为id和name又造成了重复，无法起到构造初始化的作用。此时则需要this了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id,String name)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.id  =  id;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="comment">//这就解决了问题，在这种情况下是不能省略this的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="新语法：this"><a href="#新语法：this" class="headerlink" title="新语法：this()"></a>新语法：this()</h2><p><strong>通过当前的构造方法去调用另一个本类的构造方法</strong>，可以使用以下语法格式：<br>this(实际参数列表);<br>对于this()的调用<strong>只能出现在构造方法的第一行。</strong><br>完成代码复用的功能。<br>什么意思呢？例如对于一个日期类，里面包含了  年  月  日  三个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于此类有要求：<br>如果调用无参数构造方法，默认创建的日期为：1970年1月1日。<br>一般的方法是写两个构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span></span>&#123;</span><br><span class="line">	year = <span class="number">1970</span>;</span><br><span class="line">	month = <span class="number">1</span>;</span><br><span class="line">	day = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.year = year;</span><br><span class="line">	<span class="keyword">this</span>.month = month;</span><br><span class="line">	<span class="keyword">this</span>.day = day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，两个构造方法内部基本一样的，那么就可以在第一个无参数构造方法中写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(<span class="number">1970</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样使代码简洁易懂。</p>
<hr>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;实例语句块，构造方法执行一次，这里就执行一次！&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>实例方法是写在类体之中，构造方法执行一次，这里就执行一次。<br>例如，创建一个 Student 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> idNumber;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Studnet</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="number">0</span>);<span class="comment">//默认idNumber为0</span></span><br><span class="line">	&#125;<span class="comment">//无参数构造方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Studetn</span><span class="params">(<span class="keyword">int</span> idNumber)</span></span>&#123;<span class="comment">//有参数的构造方法</span></span><br><span class="line">		<span class="keyword">this</span>.idNumber = idNumber;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//实例语句块</span></span><br><span class="line">	&#123;</span><br><span class="line"> 		 System.out.println(<span class="string">&quot;实例语句块，构造方法执行一次，这里就执行一次！&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在其他地方创建对象时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<p>就会输出一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实例语句块，构造方法执行一次，这里就执行一次！</span><br></pre></td></tr></table></figure>
<p>每调用构造方法（创建对象）时就会调用一次。</p>
<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记-4</title>
    <url>/2020/08/02/java_study_4/</url>
    <content><![CDATA[<p>继承继承继承继承</p>
<a id="more"></a>

<hr>
<h2 id="继承-Extends"><a href="#继承-Extends" class="headerlink" title="继承 Extends"></a>继承 Extends</h2><p>继承，extends<br>基础用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">如上，B类继承A类</span><br></pre></td></tr></table></figure>

<p>继承的特性如下：</p>
<p>① B类继承A类，则称A类为超类(superclass)、父类、基类，B类则称为子类(subclass)、派生类、扩展类。我们平时聊天说的比较多的是：<strong>父类和子类</strong>。<br>② java 中的继承只支持单继承，<strong>不支持多继承</strong>，C++中支持多继承，这也是 java 体现简单性的一点，换句话说，java 中不允许这样写代码：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">C</span></span>&#123;&#125;</span><br><span class="line">这是错误的。</span><br></pre></td></tr></table></figure>
<p>③ 虽然 java 中<strong>不支持多继承</strong>，但有的时候会产生<strong>间接继承</strong>的效果，例如：class C extends B，class B extends A，也就是说，C 直接继承 B，其实 C 还间接继承 A。<br>④ java 中规定，子类继承父类，<strong>除构造方法不能继承之外，剩下都可以继承。</strong>但是<strong>私有</strong>的属性<strong>无法在子类中直接访问</strong>。(父类中private修饰的不能在子类中直接访问。可以通过间接的手段来访问。)<br>⑤ java 中的类没有显示的继承任何类，则<strong>默认继承 Object类</strong>，Object类是 java 语言提供的根类（老祖宗类），也就是说，一个对象与生俱来就有 Object类型中所有的特征。<br>⑥ 继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它们之间的<strong>耦合度非常高</strong>，Account 类发生改变之后会马上影响到 CreditAccount 类。</p>
<p>具体继承的解释用法</p>
<p>首先建立一个  银行账户类，包含账户的账号和余额</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 银行账户类</span></span><br><span class="line"><span class="comment">// 账户的属性：账号、余额</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;<span class="comment">//父类</span></span><br><span class="line">	<span class="comment">// 属性</span></span><br><span class="line">	<span class="keyword">private</span> String actno;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String actno, <span class="keyword">double</span> balance)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.actno = actno;</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// setter and getter</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActno</span><span class="params">(String actno)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.actno = actno;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getActno</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> actno;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> balance;</span><br><span class="line"> 	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再建立一个新的类：信用卡账户类<br>除了上述银行账户类所含的属性外，还包含“信誉度”属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新的类：信用卡账户</span></span><br><span class="line"><span class="comment">//除了上述银行账户类所含的属性外，还包含“信誉度”属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditAccount</span> <span class="keyword">extends</span> <span class="title">Account</span></span>&#123;<span class="comment">//子类</span></span><br><span class="line">	<span class="comment">// 属性</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> credit;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CreditAccount</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">// setter and getter方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCredit</span><span class="params">(<span class="keyword">double</span> credit)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.credit = credit;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCredit</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		 <span class="keyword">return</span> credit;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由继承可知，在CreditAccount中，同样包含了Account中的actno和balance，且包含了Account中的所有setter和getter。<br>所以可以在主类对他们操作时，这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 创建普通账户</span></span><br><span class="line">	Account act = <span class="keyword">new</span> Account();</span><br><span class="line">	act.setActno(<span class="string">&quot;1111111&quot;</span>);</span><br><span class="line">	act.setBalance(<span class="number">10000</span>);</span><br><span class="line">	System.out.println(act.getActno() + <span class="string">&quot;,余额&quot;</span> + act.getBalance());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建信用账户</span></span><br><span class="line">	CreditAccount ca = <span class="keyword">new</span> CreditAccount();</span><br><span class="line">	ca.setActno(<span class="string">&quot;2222222&quot;</span>);</span><br><span class="line">	ca.setBalance(-<span class="number">10000</span>);</span><br><span class="line">	ca.setCredit(<span class="number">0.99</span>);</span><br><span class="line">	System.out.println(ca.getActno() + <span class="string">&quot;,余额&quot;</span> + ca.getBalance() + <span class="string">&quot;,信誉度&quot;</span> + ca.getCredit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在上述代码中，明明在CreditAccount类中没有写setActno和setBalance等方法，但是由于继承，可以去调用写在父类的这类方法。</p>
<p>但是注意：<strong>构造方法不能继承，并且在子类中是无法直接访问父类中的private修饰的变量的。</strong></p>
<p>例如，如下写法是<strong>错误</strong>的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(actno);</span><br><span class="line">错误: actno 在 Account 中是 <span class="keyword">private</span> 访问控制</span><br></pre></td></tr></table></figure>
<p>因为 引用 ca是CreditAccount类创建的，其中并没有actno，actno是在父类之中且属于private修饰的私有变量，所以这样使无法直接访问的。</p>
<p>那么要如何去访问呢？<br>答案是：通过继承的setter和getter方法去访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(getActno());</span><br></pre></td></tr></table></figure>
<p>如此，便可以对父类中的私有变量进行访问和修改了。</p>
<hr>
<h2 id="在实际开发中，满足什么条件的时候，我可以使用继承呢？"><a href="#在实际开发中，满足什么条件的时候，我可以使用继承呢？" class="headerlink" title="在实际开发中，满足什么条件的时候，我可以使用继承呢？"></a>在实际开发中，满足什么条件的时候，我可以使用继承呢？</h2><p><strong>凡是采用“is a”能描述的，都可以继承。</strong><br>例如：<br>    Cat is a Animal：猫是一个动物（Cat类继承Animal类）<br>    Dog is a Animal：狗是一个动物（Dog类继承Animal类）<br>    CreditAccount is a Account：信用卡账户是一个银行账户（CreditAccount 继承Account类）<br><strong>注意：并不是两个类有相同的代码就要继承，一定要有”is a”的关系！</strong></p>
<hr>
<h2 id="对System-out-println-“Hello-World-”-的解读"><a href="#对System-out-println-“Hello-World-”-的解读" class="headerlink" title="对System.out.println(“Hello World!”);的解读"></a>对System.out.println(“Hello World!”);的解读</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>现在再来看这段代码，可以理解到：<br>System是一个类名<br>out是一个变量名<br>println是一个方法名<br>类名.变量名.方法名  说明这个变量是一个静态变量。<br>例如下串代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  		Student s = Test.stu;</span><br><span class="line">  		s.exam();</span><br><span class="line">  		<span class="comment">//上2行合并为1行</span></span><br><span class="line">  		Test.stu.exam();</span><br><span class="line">  		<span class="comment">//类比于</span></span><br><span class="line">  		System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;EXAM&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记6（super）</title>
    <url>/2020/08/04/java_study_6/</url>
    <content><![CDATA[<hr>
<h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><p>今天学习的是super =w=</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">super</span>是一个关键字，全部小写。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">super</span>和<span class="keyword">this</span>对比着学习。</span><br><span class="line">	<span class="keyword">this</span>:</span><br><span class="line">		<span class="keyword">this</span>能出现在实例方法和构造方法中。</span><br><span class="line">		<span class="keyword">this</span>的语法是：“<span class="keyword">this</span>.”、“<span class="keyword">this</span>()”</span><br><span class="line">		<span class="keyword">this</span>不能使用在静态方法中。</span><br><span class="line">		<span class="keyword">this</span>. 大部分情况下是可以省略的。</span><br><span class="line">		<span class="keyword">this</span>.什么时候不能省略呢？ 在区分局部变量和实例变量的时候不能省略。</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">this</span>() 只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中其它的构造方法，目的是：代码复用。</span><br><span class="line">	<span class="keyword">super</span>:</span><br><span class="line">		<span class="keyword">super</span>能出现在实例方法和构造方法中。</span><br><span class="line">		<span class="keyword">super</span>的语法是：“<span class="keyword">super</span>.”、“<span class="keyword">super</span>()”</span><br><span class="line">		<span class="keyword">super</span>不能使用在静态方法中。</span><br><span class="line">		<span class="keyword">super</span>. 大部分情况下是可以省略的。</span><br><span class="line">		<span class="keyword">super</span>.什么时候不能省略呢？父类和子类中有同名属性，或者说有同样的方法，想在子类中访问父类的，<span class="keyword">super</span>. 不能省略。</span><br><span class="line">		<span class="keyword">super</span>() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。</span><br><span class="line">		<span class="keyword">super</span>的使用：</span><br><span class="line">			<span class="keyword">super</span>.属性名    【访问父类的属性】</span><br><span class="line">			<span class="keyword">super</span>.方法名(实参)  【访问父类的方法】</span><br><span class="line">			<span class="keyword">super</span>(实参)     【调用父类的构造方法】</span><br></pre></td></tr></table></figure>
<p>上面就是关于super的用法总结，下面结合实际的代码来看super的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先定义A,B两个类，构成继承关系</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;A类的无参数构造方法！&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B类的无参数构造方法！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以看到，我们给A和B两个类提供了2个无参构造方法，在调用时会输出一段话。然后在下面的函数中去创建B对象，会输出什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest01</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> B();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>令我们惊讶的是，我们得到了如下的输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A类的无参数构造方法！</span><br><span class="line">B类的无参数构造方法！</span><br></pre></td></tr></table></figure>
<p>我们只是新建了对象B，但是却也输出了A的语句，可以证明，在创建对象B时，也调用了A的构造方法！（<strong>值得注意的是，其实我们仍然只是创建了一个对象，并不是创建了2个！</strong>）<br>那么也就意味着，在B的调用方法中，有一句隐藏的语句调用了A的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当一个构造方法第一行既没有<span class="keyword">this</span>()又没有<span class="keyword">super</span>()的话，默认会有一个<span class="keyword">super</span>();</span><br><span class="line">表示通过当前子类的构造方法调用父类的无参数构造方法。</span><br><span class="line">所以必须保证父类的无参数构造方法是存在的。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">		surper();<span class="comment">//这里如果不写别的的话，那么他是默认有一句surper()的</span></span><br><span class="line">		System.out.println(<span class="string">&quot;B类的无参数构造方法！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：this()和super() 不能共存，它们都是只能出现在构造方法第一行。</strong><br>也就是说，无论如何，当你去创建子类对象时，父类的构造方法是一定会执行的。（其道理就跟有儿子的前提一定是有爸爸一样）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">所以，如果在父类A中有一个有参数的构造方法，</span><br><span class="line">同理我们也可以在子类中通过surper(参数列表)去调用</span><br><span class="line">从而起到初始化父类中特征的目的。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Surper何时不能省略"><a href="#Surper何时不能省略" class="headerlink" title="Surper何时不能省略"></a>Surper何时不能省略</h2><p>当父中有，子中又有，如果想在子中访问“父的特征”，super. 不能省略。<br>例如以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> test&#123;</span><br><span class="line">		System.out.println(id);</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.id);</span><br><span class="line">		System.out.println(<span class="keyword">super</span>.id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">上面test方法中的三句输出是不一样的，前两句是一样的，这两个id都是指的子类B中的id</span><br><span class="line">最后一句使用了<span class="keyword">super</span>.去访问,所以这个id是父类A中的id</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Super是引用吗？"><a href="#Super是引用吗？" class="headerlink" title="Super是引用吗？"></a>Super是引用吗？</h2><p>首先回顾this，我们前面提到，如果在创建了一个对象后，直接输出他的this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">具体见前面的博客</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>我们会得到一串东西，类似于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名@<span class="number">2f</span>92e0f4</span><br><span class="line">具体含义见前面博客</span><br></pre></td></tr></table></figure>
<p>那是因为当你直接输出this时，其实会去调用Object类中的toString方法（见前）<br>我们如果直接输出super呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">super</span>)；</span><br></pre></td></tr></table></figure>
<p>我们会得到编译错误！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">编译错误: 需要<span class="string">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以证明，super起码不是引用。<br>其实，super也不保存内存地址，super也不指向任何对象。<strong>super 只是代表当前对象内部的那一块父类型的特征。</strong></p>
<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记-7(final &amp;&amp; 抽象)</title>
    <url>/2020/08/05/java_study_7/</url>
    <content><![CDATA[<p>final &amp;&amp; 抽象</p>
<a id="more"></a>



<hr>
<h2 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h2><p>final是一个关键字，小写，用来修饰 类、方法、变量、引用。</p>
<p>关于final的特征：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1</span>、<span class="keyword">final</span>修饰的类无法继承。</span><br><span class="line"><span class="number">1.2</span>、<span class="keyword">final</span>修饰的方法无法覆盖。</span><br><span class="line"><span class="number">1.3</span>、<span class="keyword">final</span>修饰的变量只能赋一次值。</span><br><span class="line"><span class="number">1.4</span>、<span class="keyword">final</span>修饰的引用一旦指向某个对象，则不能再重新指向其它对象，但该引用指向的对象内部的数据是可以修改的。</span><br><span class="line"><span class="number">1.5</span>、<span class="keyword">final</span>修饰的实例变量必须手动初始化，不能采用系统默认值。</span><br><span class="line"><span class="number">1.6</span>、<span class="keyword">final</span>修饰的实例变量一般和<span class="keyword">static</span>联合使用，称为常量。</span><br><span class="line">例如：<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure>
<p>总之，final的修饰意思为：初始化后无法再去改变。</p>
<hr>
<h2 id="抽象类abstract"><a href="#抽象类abstract" class="headerlink" title="抽象类abstract"></a>抽象类abstract</h2><p>每个对象（实例），将他们的共同特点抽象出来是一个大类。<br>而每个类如果又有共同特征呢？把他们抽象出来，便是一个抽象类。<br>如下图所画：<br><img src="https://img-blog.csdnimg.cn/20200807170127388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="图源动力节点教程"><br>首先来说抽象类的定义方法：<br><strong>abstract</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">	类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于抽象 abstract 值得注意的是：</p>
<ul>
<li>抽象类是由类抽象而来，然而类本来是不存在的，所以抽象类无法创建对象。例如下面这个：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;	</span><br><span class="line">&#125;</span><br><span class="line">创建了一个抽象类，那么我们就无法去使用</span><br><span class="line"><span class="keyword">new</span> Account();<span class="comment">//错误: Account是抽象的; 无法实例化</span></span><br><span class="line">去创建对象。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>抽象类也属于引用数据类型。</p>
</li>
<li><p>正因为抽象类是无法被实例化的，所以抽象类生来就是要被继承的。“生被继承，我很惭愧”</p>
</li>
<li><p>final和abstract不能联合使用，这两个关键字是对立的。(为什么？前面我们提到：<em>final修饰的类无法继承</em> ，然而abstract修饰的抽象类是要天生就被继承的，所以他们是矛盾，对立的。)</p>
</li>
<li><p>抽象类的子类可以是抽象类。也可以是非抽象类。（抽！我疯狂地抽！）</p>
</li>
<li><p>抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。（通过前面讲的super去调用父类的构造方法）</p>
</li>
</ul>
<hr>
<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>抽象类中可以有<strong>抽象方法</strong>，抽象方法表示没有实现的方法，没有方法体的方法。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>;</span><br><span class="line">抽象方法特点是：</span><br><span class="line">	特点<span class="number">1</span>：没有方法体，以分号结尾。</span><br><span class="line">	特点<span class="number">2</span>：前面修饰符列表中有<span class="keyword">abstract</span>关键字。</span><br></pre></td></tr></table></figure>

<p>关于抽象方法，注意！<strong>抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。</strong><br>正因为这个注意点，结合到继承的特点（子类继承父类的方法）我们不难想到，<strong>在子类之中，必须对抽象方法进行覆盖/重写/实现！</strong></p>
<hr>
<h2 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h2><p>别看我，我也没搞明白·······<br>大概是通过抽象类和多态去写程序？<br>（咋不用抽象话呢····迫真–面向抽象编程）</p>
<hr>
<h2 id="小tip"><a href="#小tip" class="headerlink" title="小tip"></a>小tip</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">面试题（判断题）：java语言中凡是没有方法体的方法都是抽象方法。</span><br><span class="line">		不对，错误的。</span><br><span class="line">		Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们都不是抽象方法，例如：</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">		这个方法底层调用了C++写的动态链接库程序。</span><br><span class="line">		前面修饰符列表中没有：<span class="keyword">abstract</span>。有一个<span class="keyword">native</span>。表示调用JVM本地程序。</span><br></pre></td></tr></table></figure>
<p>看不懂，不要问，学废了</p>
<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记5（方法覆盖和多态）</title>
    <url>/2020/08/03/java_study_5/</url>
    <content><![CDATA[<p>方法覆盖和多态！</p>
<a id="more"></a>

<hr>
<h2 id="什么时候进行方法覆盖？"><a href="#什么时候进行方法覆盖？" class="headerlink" title="什么时候进行方法覆盖？"></a>什么时候进行方法覆盖？</h2><p>父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。</p>
<hr>
<h2 id="方法覆盖的语法"><a href="#方法覆盖的语法" class="headerlink" title="方法覆盖的语法"></a>方法覆盖的语法</h2><p>首先，来看看在JAVA自带的Object类中的toString方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当我们在实际方法中调用这个方法时，往往其默认的方法不能满足我们的需求<br>例如我们创建一个日期类，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>(<span class="number">1970</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.year = year;</span><br><span class="line">  		<span class="keyword">this</span>.month = month;</span><br><span class="line">  		<span class="keyword">this</span>.day = day;</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> year)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.year = year;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> year;</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMonth</span><span class="params">(<span class="keyword">int</span> month)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.month = month;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> month;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDay</span><span class="params">(<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.day = day;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> day;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们去用这个类创建一个对象，并且调用toString方法时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		MyDate t1 = <span class="keyword">new</span> MyDate();</span><br><span class="line">		<span class="comment">//覆盖toString之前</span></span><br><span class="line">		System.out.println(t1.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不对其进行覆盖重写，那么我们将会得到如下结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyDate@<span class="number">28</span>a418fc</span><br></pre></td></tr></table></figure>
<p>注意：并不是每个人得到的默认结果都一样，因为在Object类中toString默认实现为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>
<p>可以看到，默认是返回一个”类名”+@+一串对象在堆内存当中的内存地址<br>当然，这个地址只是“等同”可看做对象在堆内存当中的内存地址，他实际是内存地址经过“哈希算法”得出的十六进制结果。</p>
<p>这个时候问题来了，我们希望当通过MyDate的对象调用toString方法时，是输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xx年xx月xx日</span><br></pre></td></tr></table></figure>
<p>而不是一串复杂的字符串，这个时候，满足了方法覆盖的需求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。</span><br></pre></td></tr></table></figure>
<p>所以，我们决定对Object类中的toString方法进行覆盖（重写）<br>首先，要注意的是，方法覆盖必须要满足的条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一：有继承关系的两个类（在这里，MyDate类默认继承了Object类，满足）</span><br><span class="line">第二：具有相同方法名、返回值类型、形式参数列表（见下）</span><br><span class="line">第三：访问权限不能更低。（暂时未懂）</span><br><span class="line">第四：抛出异常不能更多。（暂时未懂）</span><br></pre></td></tr></table></figure>
<p>那么现在开始对toString方法进行覆盖，代码如下<br><strong>在原来的MyDate类中，加上这么一段代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//toString方法的覆盖</span></span><br><span class="line"><span class="comment">//具有相同方法名、返回值类型、形式参数列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再去调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		MyDate t1 = <span class="keyword">new</span> MyDate();</span><br><span class="line">		<span class="comment">//覆盖toString之后</span></span><br><span class="line">		System.out.println(t1.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日</span><br><span class="line"><span class="comment">//因为在无参构造方法中，用了this()去调用有参构造方法，所以默认为1970年1月1日</span></span><br><span class="line"><span class="comment">//具体见上篇博客</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="方法覆盖注意点"><a href="#方法覆盖注意点" class="headerlink" title="方法覆盖注意点"></a>方法覆盖注意点</h2><p><strong>方法覆盖/重写的时候，建议将父类的方法复制粘贴，这样比较保险。</strong></p>
<hr>
<h2 id="方法覆盖与方法重载的区别"><a href="#方法覆盖与方法重载的区别" class="headerlink" title="方法覆盖与方法重载的区别"></a>方法覆盖与方法重载的区别</h2><p>首先回顾一下<strong>方法重载</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">什么时候考虑使用方法重载overload？</span><br><span class="line">	当在一个类当中，如果功能相似的话，建议将名字定义的一样，这样代码美观，并且方便编程。</span><br><span class="line">什么条件满足之后能够构成方法重载overload？</span><br><span class="line">	条件一：在同一个类当中</span><br><span class="line">	条件二：方法名相同</span><br><span class="line">	条件三：参数列表不同（个数、顺序、类型）</span><br></pre></td></tr></table></figure>

<p>再来看看<strong>方法覆盖</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">什么时候我们会考虑使用“方法覆盖”呢？</span><br><span class="line">	子类继承父类之后，当继承过来的方法无法满足当前子类的业务需求时</span><br><span class="line">	子类有权利对这个方法进行重新编写，有必要进行“方法的覆盖”。</span><br><span class="line">方法覆盖又叫做：方法重写（重新编写），英语单词叫做：Override、Overwrite，都可以。</span><br><span class="line">比较常见的：方法覆盖、方法重写、override</span><br><span class="line">重要结论：</span><br><span class="line">	当子类对父类继承过来的方法进行“方法覆盖”之后，</span><br><span class="line">	子类对象调用该方法的时候，一定执行覆盖之后的方法。</span><br><span class="line">当我们代码怎么编写的时候，在代码级别上构成了方法覆盖呢？</span><br><span class="line">	条件一：两个类必须要有继承关系。</span><br><span class="line">	条件二：重写之后的方法和之前的方法具有：</span><br><span class="line">		相同的返回值类型</span><br><span class="line">		相同的方法名</span><br><span class="line">		相同的形式参数列表</span><br><span class="line">	条件三：访问权限不能更低，可以更高</span><br><span class="line">	条件四：重写之后的方法不能比之前的方法抛出更多的异常，可以更少</span><br><span class="line">注意事项：</span><br><span class="line">	注意<span class="number">1</span>：方法覆盖只是针对于方法，和属性无关。</span><br><span class="line">	注意<span class="number">2</span>：私有方法无法覆盖。</span><br><span class="line">	注意<span class="number">3</span>：构造方法不能被继承，所以构造方法也不能被覆盖。</span><br><span class="line">	注意<span class="number">4</span>：方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。	</span><br></pre></td></tr></table></figure>
<p>通过回顾总结，可以看到，两个区别还是很大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法重载  发生在同一个类当中。</span><br><span class="line">方法覆盖  是发生在具有继承关系的父子类之间。</span><br><span class="line">方法重载  是一个类中，方法名相同，参数列表不同。</span><br><span class="line">方法覆盖  是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：</span><br><span class="line">		方法名一致、参数列表一致、返回值类型一致。</span><br></pre></td></tr></table></figure>

<p><strong>初学方法覆盖时，的确会有困惑：<br>这玩意啥用？我重新写个方法不一样能实现？<br>但是方法覆盖对后续 多态 是十分重要的，所以先学习记住，后面就有用了。</strong></p>
<hr>
<h2 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h2><p>向上转型：子 —&gt; 父（自动类型转换）（无风险）<br>向下转型：父 —&gt; 子（强制类型转换，需要加强制类型转换符）（有风险，用instanceof运算符判断）</p>
<p><strong>注意：无论是向上转型，还是向下转型，两种类型之间必须有继承关系，没有继承关系编译器报错。</strong></p>
<p>通过具体的代码段来看向上转型和向下转型</p>
<p>先写一个 Animal 类，作为父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;动物在移动！！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写一个Cat类，作为子类继承父类 Animal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="comment">//对move方法覆盖重写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;cat走猫步！&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们在主方法中来写这么一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	Animal a1 = <span class="keyword">new</span> Cat();</span><br><span class="line">	a1.move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>跟我们以前写的不一样！在这里，引用 a1 是 Animal 类型，但是，他所指向的对象却是 Cat 类型！</strong><br>这里就是一个向上转型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a1 = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>
<p>可以看到，是把Cat类型的对象（子）——&gt;Animal类型的引用（父），这就是一个向上转型。<br>而且a1.move()是调用的Cat类中的（覆盖过的）move方法！<br>所以我们得到这样的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat走猫步！</span><br></pre></td></tr></table></figure>
<p>这就是一个多态，<strong>多种形态，多种状态。</strong></p>
<p>那么向下转型呢？如下代码段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c1 = (Cat)a1;</span><br></pre></td></tr></table></figure>
<p><strong>这就是向下转型，但是记住！有风险！</strong></p>
<hr>
<h2 id="向下转型的风险-amp-amp-异常-ClassCastException"><a href="#向下转型的风险-amp-amp-异常-ClassCastException" class="headerlink" title="向下转型的风险&amp;&amp;异常:ClassCastException"></a>向下转型的风险&amp;&amp;异常:ClassCastException</h2><p>在上面的向下转型，我们仅仅写了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c1 = (Cat)a1;</span><br></pre></td></tr></table></figure>
<p>的确完成了任务，编译器也没报错，但是如果我们的a1是一个指向非Cat的对象的引用呢？<br>首先我们新写一个类：Bird  作为 Animal 的子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//对move方法覆盖</span></span><br><span class="line">		System.out.println(<span class="string">&quot;鸟儿在飞翔！！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们去创建一个引用（Animal类）去指向Bird类中的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同样也是一个向上转型</span></span><br><span class="line">Animal a2 = <span class="keyword">new</span>() Bird;</span><br></pre></td></tr></table></figure>
<p>然后我们去向上面一样，去向下转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c2 = (Cat)a2;</span><br></pre></td></tr></table></figure>
<p><strong>是的！这是十分危险的！</strong><br>我们知道，a2是一个Animal类型的引用变量，那么他在<strong>编译时，这段代码是完全没问题的！</strong><br>因为在编译时，编译器仅仅检测到a2是一个Animal类型引用，且Animal与Cat的确有继承关系，所以，这段话<strong>通过编译完全没问题！</strong>（关于编译时和运行时的区别见下）<br>但是这里就产生了矛盾：a2明明指向的是一个Bird类型的对象，却将它强转为了Cat类型，他们之间是<strong>不存在继承关系的！</strong><br>当然，单单实现这一行代码，是完全没问题的，也不会报错。如果我们继续往下写，让c2去调用<strong>Cat类中独有的方法</strong>呢？<br>（<strong>注意，此时c2是通过a2强转而来，但是a2实际上是指向Bird的一个引用，在Bird中是不存在Cat中的独有方法的！我们不难想象这样的调用必然出问题！</strong>）<br>首先我们当然得先给Cat类加上一个<strong>独有的方法</strong>（意思是这个方法仅仅在Cat这个子类中存在，<strong>在父类Animal中不存在！</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 猫除了move之外，应该有自己特有的行为，例如抓老鼠。</span></span><br><span class="line"><span class="comment">// 这个行为是子类型对象特有的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;猫正在抓老鼠！！！！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们去通过c2调用cathMouse方法，可以吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c2.catchMouse();</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="title">cannot</span> <span class="title">be</span> <span class="title">cast</span> <span class="title">to</span> <span class="title">class</span> <span class="title">Cat</span> (<span class="title">Bird</span> <span class="title">and</span> <span class="title">Cat</span> <span class="title">are</span> <span class="title">in</span> <span class="title">unnamed</span> <span class="title">module</span> <span class="title">of</span> <span class="title">loader</span> &#x27;<span class="title">app</span>&#x27;)</span></span><br><span class="line"> at CaoGao.main(CaoGao.java:4)</span><br></pre></td></tr></table></figure>
<p>这里的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassCastException</span><br></pre></td></tr></table></figure>
<p>就是一个很重要的异常：类型转换异常。从提示可以看出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="title">cannot</span> <span class="title">be</span> <span class="title">cast</span> <span class="title">to</span> <span class="title">class</span> <span class="title">Cat</span></span></span><br></pre></td></tr></table></figure>
<p>Bird类无法转换为Cat类，因为他们没有继承！所以这就是向下转型的风险所在。</p>
<p><strong>当然，我们可以趁机总结下，何时使用向下转型：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当我们需要调用子类中 特有的方法 时，便需要向下转型</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="运用instanceof运算符来避免向下转型风险"><a href="#运用instanceof运算符来避免向下转型风险" class="headerlink" title="运用instanceof运算符来避免向下转型风险"></a>运用instanceof运算符来避免向下转型风险</h2><p>instanceof（运行阶段动态判断）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一：<span class="keyword">instanceof</span>可以在运行阶段动态判断引用指向的对象的类型。</span><br><span class="line">第二：<span class="keyword">instanceof</span>的语法：(引用 <span class="keyword">instanceof</span> 类型)</span><br><span class="line">第三：<span class="keyword">instanceof</span>运算符的运算结果只能是：<span class="keyword">true</span>/<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">例如：c是一个引用，c变量保存了内存地址指向了堆中的对象。</span><br><span class="line">	假设(c <span class="keyword">instanceof</span> Cat)为<span class="keyword">true</span>表示:c引用指向的堆内存中的java对象是一个Cat。</span><br><span class="line">	假设(c <span class="keyword">instanceof</span> Cat)为<span class="keyword">false</span>表示:c引用指向的堆内存中的java对象不是一个Cat。</span><br><span class="line"></span><br><span class="line">使用<span class="keyword">instanceof</span> 运算符进行判断可以很好的避免：ClassCastException</span><br></pre></td></tr></table></figure>
<p>具体写法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a2 <span class="keyword">instanceof</span> Cat)<span class="comment">// 如果a6是Cat</span></span><br><span class="line">&#123;</span><br><span class="line">	Cat c2 = (Cat)a2;<span class="comment">// 再进行向下转型</span></span><br><span class="line">	c2.catchMouse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时便可以通过判断后再去决定是否进行向下转型，这是必须写的一步！！！</p>
<hr>
<h2 id="编译和运行时期的区别"><a href="#编译和运行时期的区别" class="headerlink" title="编译和运行时期的区别"></a>编译和运行时期的区别</h2><p>编译期叫做静态绑定。<br>运行期叫做动态绑定。<br>具体针对下面这段代码来去分析区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a3 = <span class="keyword">new</span> Cat()；</span><br><span class="line">a3.move();</span><br></pre></td></tr></table></figure>
<p>java程序分为编译阶段和运行阶段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先来分析编译阶段：</span><br><span class="line">	对于编译器来说，编译器只知道a3的类型是Animal，</span><br><span class="line">	所以编译器在检查语法的时候，会去Animal.class字节码文件中找move()方法，</span><br><span class="line">	找到了，绑定上move()方法，编译通过，静态绑定成功。（编译阶段属于静态绑定。）</span><br><span class="line">再来分析运行阶段：</span><br><span class="line">	运行阶段的时候，实际上在堆内存中创建的java对象是Cat对象，所以move的时候，真正参与move的对象是Cat</span><br><span class="line">	所以运行阶段会动态执行Cat对象的move()方法。这个过程属于运行阶段绑定。（运行阶段绑定属于动态绑定。）</span><br></pre></td></tr></table></figure>
<p>所以不难解释，为什么在上面所写的有风险的向下转型之中，编译时可以通过的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c2 = (Cat)a2;</span><br></pre></td></tr></table></figure>
<p>这里，a2所指向的是一个在堆内存中的Bird对象，但是在编译时，编译器并不知道这一点，因为编译时还未创建对象！所以编译器仅仅知道a2是一个Animal类型的变量，且Animal与Cat继承，所以他认为这段代码没问题，编译通过！</p>
<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记-8（接口的基本语法）</title>
    <url>/2020/08/06/java_study_8/</url>
    <content><![CDATA[<p>接口的基本语法</p>
<a id="more"></a>



<hr>
<h2 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h2><p>关于接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、接口也是一种“引用数据类型”。编译之后也是一个<span class="class"><span class="keyword">class</span>字节码文件。</span></span><br><span class="line"><span class="class">2、接口是完全抽象的。（抽象类是半抽象。）或者也可以说接口是特殊的抽象类。</span></span><br><span class="line"><span class="class">3、接口怎么定义，语法是什么？</span></span><br><span class="line">	[修饰符列表] interface 接口名&#123;&#125;</span><br><span class="line"><span class="number">4</span>、接口支持多继承，一个接口可以继承多个接口。</span><br><span class="line"><span class="number">5</span>、接口中只包含两部分内容，一部分是：常量。一部分是：抽象方法。</span><br><span class="line"><span class="number">6</span>、接口中所有的元素都是<span class="keyword">public</span>修饰的</span><br><span class="line"><span class="number">7</span>、接口中抽象方法的<span class="keyword">public</span> <span class="keyword">abstract</span>可以省略。</span><br><span class="line"><span class="number">8</span>、接口中常量的<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>可以省略。</span><br></pre></td></tr></table></figure>
<p>例如如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">100</span>;<span class="comment">//k是常量，在接口中常量的public static final可以省略。</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;<span class="comment">//sum是抽象方法，接口中抽象方法的public abstract可以省略。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;&#125;<span class="comment">// 一个接口可以继承多个接口（支持多继承）</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现implements"><a href="#实现implements" class="headerlink" title="实现implements"></a>实现implements</h2><blockquote>
<p>类和类之间叫做继承，类和接口之间叫做实现。<br>继承使用extends关键字完成。<br>实现使用implements关键字完成。</p>
</blockquote>
<p>注意：接口（interface）也是抽象的，所以说抽象类的注意事项在接口处同样适用，例如无法实例化等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当一个非抽象的类实现接口的话，</span><br><span class="line">必须将接口中所有的抽象方法全部实现（覆盖、重写）!!!</span><br></pre></td></tr></table></figure>

<p>如下定义接口MyMath:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMathImpl</span> <span class="keyword">implements</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a - b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主方法可以这样调用接口和类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	MyMath mm = <span class="keyword">new</span> MyMathImpl();<span class="comment">//多态</span></span><br><span class="line">	<span class="keyword">int</span> result1 = mm.sum(<span class="number">10</span>, <span class="number">20</span>);<span class="comment">// 调用接口里面的方法（面向接口编程。）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="一个类可以同时实现多个接口"><a href="#一个类可以同时实现多个接口" class="headerlink" title="一个类可以同时实现多个接口"></a>一个类可以同时实现多个接口</h2><blockquote>
<p>接口和接口之间支持多继承且一个类可以同时实现多个接口。</p>
</blockquote>
<p>这种机制弥补了java中类和类只支持单继承的缺陷！现在也可以实现类似的多继承了！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span></span>&#123;&#125;<span class="comment">//一个类同时实现多个接口</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="继承和实现同时存在"><a href="#继承和实现同时存在" class="headerlink" title="继承和实现同时存在"></a>继承和实现同时存在</h2><blockquote>
<p>继承和实现都存在的话，代码应该怎么写？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">extends 关键字在前。</span><br><span class="line">implements 关键字在后。</span><br></pre></td></tr></table></figure>
<p>例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;&#125;<span class="comment">//继承和实现同时存在</span></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记9-（接口和package和import）</title>
    <url>/2020/08/07/java_study_9/</url>
    <content><![CDATA[<p>接口和package和import</p>
<a id="more"></a>





<h2 id="接口在开发中的作用"><a href="#接口在开发中的作用" class="headerlink" title="接口在开发中的作用"></a>接口在开发中的作用</h2><p>面向接口编程，也就是面向抽象编程，能够降低程序的耦合度，提高程序的扩展力。<br>啥？为啥不给代码例子？…………<br>这个东西，只可意会，不可言传。<br>写得多了自然理解了……<br>接口的使用离不开多态机制。（接口+多态才可以达到降低耦合度。）</p>
<hr>
<h2 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h2><blockquote>
<p>is a（继承）、has a（关联）、like a（实现）</p>
</blockquote>
<blockquote>
<p>is a：<br>       Cat is a Animal（猫是一个动物）<br>       凡是能够满足is a的表示“继承关系”<br>       A extends B</p>
</blockquote>
<blockquote>
<p>has a：<br>       He has a Pen（他有一支笔）<br>       凡是能够满足has a关系的表示“关联关系”<br>       关联关系通常以“属性”的形式存在。</p>
</blockquote>
<blockquote>
<p>like a:<br>       Cooker like a FoodMenu（厨师像一个菜单一样）<br>       凡是能够满足like a关系的表示“实现关系”<br>       实现关系通常是：类实现接口。<br>       A implements B</p>
</blockquote>
<hr>
<h2 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h2><ul>
<li><p>抽象类是半抽象的，接口是完全抽象的。</p>
</li>
<li><p>抽象类中有构造方法，接口中没有构造方法。</p>
</li>
<li><p>接口和接口之间支持多继承，类和类之间只能单继承。</p>
</li>
<li><p>一个类可以同时实现多个接口，一个抽象类只能继承一个类（单继承）。</p>
</li>
<li><p>接口中只允许出现常量和抽象方法。</p>
</li>
<li><p>以后接口使用的比抽象类多。一般抽象类使用的还是少。接口一般都是对“行为”的抽象。</p>
</li>
</ul>
<hr>
<h2 id="package和import"><a href="#package和import" class="headerlink" title="package和import"></a>package和import</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>在IDEA工具中，新建package的方法如下：<br><img src="https://img-blog.csdnimg.cn/20200808152747686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="新建package"><br>在输入名字时，若package的名字为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.b.c</span><br></pre></td></tr></table></figure>
<p>意思是这个包（package）包含了3个文件夹（a和b和c）<br>如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020080815293940.png" alt="abc"><br>在a包中去编写代码（新建class文件），可以看到在文件最上方有这么一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> a;</span><br><span class="line">意思是这个文件在a包中。</span><br></pre></td></tr></table></figure>
<p>值得注意点：</p>
<blockquote>
<p>package出现在java源文件第一行。<br>以后说类名的时候，如果带着包名描述，表示完整类名。<br>如果没有带包，描述的话，表示简类名。<br>例如：java.util.Scanner 完整类名。（可以在java文件夹下的util文件夹找到Scanner文件）<br>Scanner 简类名</p>
</blockquote>
<p>关于上述java.util.Scanner 的图片演示<br><img src="https://img-blog.csdnimg.cn/20200808153811703.png" alt="1"><br><img src="https://img-blog.csdnimg.cn/20200808153819430.png" alt="2"></p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><blockquote>
<p>import什么时候不需要？<br>java.lang同包下不需要。<br>其它一律都需要。<br>例如在java.lang下有String.java<br>但是我们用String的时候并没有写java.lang.String,而是直接写String就行。<br>经过测试，写成java.lang.String也是可以的。<br>这就说明在java.lang同包下不需要import。</p>
</blockquote>
<p>在IDEA中如何使用？<br>首先要明确，IDEA开发工具是可以自动导入所缺失的包的。<br>如下图，在没有导入java.util包的情况下，我们调用Scanner<br><img src="https://img-blog.csdnimg.cn/20200808161958864.png" alt="1"><br>系统会提示我们导入class，点击即可自动导入。<br><img src="https://img-blog.csdnimg.cn/20200808162025918.png" alt="2"><br><del>（IDEA万岁！）</del> </p>
<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记-内存篇</title>
    <url>/2020/08/05/java_study_mem/</url>
    <content><![CDATA[<hr>
<p>让我们来看看JAVA的内存图！</p>
<a id="more"></a>

<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>Java开发工具箱<br>Java Development Kit</p>
<hr>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>Java Run Environment<br>java运行环境</p>
<hr>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>java虚拟机</p>
<p>程序是在JRE的JVM里面运行的，所以内存是指的在JVM中<br>分为<br><strong>栈区</strong><br><strong>堆区<br>方法区</strong></p>
<hr>
<h2 id="栈："><a href="#栈：" class="headerlink" title="栈：!"></a>栈：!</h2><p><a href="https://img-blog.csdnimg.cn/20200731161812711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70">这是栈区的数据结构的示意图，图源动力节点教程</a></p>
<p>JVM中的内存结构图<br><img src="https://img-blog.csdnimg.cn/20200731162013154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="JVM中主要的三块内存空间，图源动力节点教程"></p>
<p>可以知道，栈区是储存方法的，当调用方法时，就会在栈区开辟一块内存，如下图<br><img src="https://img-blog.csdnimg.cn/20200731162309506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="方法执行过程中的内存变化，图源动力节点"></p>
<hr>
<h2 id="堆：！"><a href="#堆：！" class="headerlink" title="堆：！"></a>堆：！</h2><p>堆区是存放关于对象的数据，每new一个对象，就会在堆区开辟一块内存去存储这个对象。如下图<br><img src="https://img-blog.csdnimg.cn/20200731162532606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="对象和引用，图源动力节点"><br>那么空指针异常的发生在内存图是如何表示的呢？我们已经知道，空指针异常是在引用为null的时候，用其访问实例变量或实例方法发生的，在内存图中如下所示<br><img src="https://img-blog.csdnimg.cn/20200731162714900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="空指针异常是怎么发生的，图源动力节点"><br>在对象中存在一个关键字  this，他在内存图中的位置是存在于堆中的对应对象中的，如下图所示<br><img src="https://img-blog.csdnimg.cn/20200731162856799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="this关键字，图源动力节点"><br>static修饰的变量和方法被称为静态变量/静态方法，他们是存储在方法区的，也就是在类加载的时候最先被加载。<br><img src="https://img-blog.csdnimg.cn/20200731163101636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70" alt="静态变量和静态方法的储存，图源动力节点"><br>静态static修饰的都是在方法区存储，在类加载是执行，且按照顺序由上而下执行！</p>
<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记14-（String）</title>
    <url>/2020/08/12/java_study_14/</url>
    <content><![CDATA[<p>JAVA学习笔记14-（String）</p>
<a id="more"></a>



<hr>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>关于String类，在API中可以看到有很多很多的方法可以去调用，下面来对重要的部分进行介绍。</p>
<hr>
<h2 id="String字符串的存储原理"><a href="#String字符串的存储原理" class="headerlink" title="String字符串的存储原理"></a>String字符串的存储原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于Java JDK中内置的一个类：java.lang.String</span><br><span class="line">	<span class="number">1</span>、String表示字符串类型，属于引用数据类型，不属于基本数据类型。</span><br><span class="line">	<span class="number">2</span>、在java中随便使用双引号括起来的都是String对象。例如：<span class="string">&quot;abc&quot;</span>，<span class="string">&quot;def&quot;</span>，<span class="string">&quot;hello world!&quot;</span>，这是<span class="number">3</span>个String对象。</span><br><span class="line">	<span class="number">3</span>、java中规定，双引号括起来的字符串，是不可变的，也就是说<span class="string">&quot;abc&quot;</span>自出生到最终死亡，不可变，不能变成<span class="string">&quot;abcd&quot;</span>，也不能变成<span class="string">&quot;ab&quot;</span></span><br><span class="line">	<span class="number">4</span>、在JDK当中双引号括起来的字符串，例如：<span class="string">&quot;abc&quot;</span> <span class="string">&quot;def&quot;</span>都是直接存储在“方法区”的“字符串常量池”当中的。</span><br><span class="line">	为什么SUN公司把字符串存储在一个“字符串常量池”当中呢。</span><br><span class="line">	因为字符串在实际的开发中使用太频繁。为了执行效率，所以把字符串放到了方法区的字符串常量池当中。</span><br></pre></td></tr></table></figure>
<p>例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这两行代码表示底层创建了<span class="number">3</span>个字符串对象，都在字符串常量池当中。</span><br><span class="line">String s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abcdef&quot;</span> + <span class="string">&quot;xy&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如下的内存图去帮助理解：<br><img src="https://img-blog.csdnimg.cn/20200814081804473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>可以看到，s1和s2是在main方法中的局部变量，所以存储在栈，但是字符串是存储在方法区的字符串常量池之中，所以s1和s2是直接存储的这片的地址。同时可以知道，如果再去通过其他的引用访问相同的字符串时，他们会指向同一个地址！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果通过String s3 = <span class="keyword">new</span> String(<span class="string">&quot;xy&quot;</span>);的方法去创建字符串呢？</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;xy&quot;</span>);</span><br><span class="line">分析：这是使用<span class="keyword">new</span>的方式创建的字符串对象。这个代码中的<span class="string">&quot;xy&quot;</span>是从哪里来的？</span><br><span class="line">凡是双引号括起来的都在字符串常量池中有一份。</span><br><span class="line"><span class="keyword">new</span>对象的时候一定在堆内存当中开辟空间。</span><br></pre></td></tr></table></figure>
<p>所以如上图的s3所示，首先，因为new了对象，所以现在堆内存开辟一块空间去存储，然后又因为字符串（凡是被“”括起来的东西都是）存储在方法区的字符串常量池当中，所以堆内存中对象有存储着方法区字符串常量池的对应字符串的地址。</p>
<hr>
<p>我们再去对我们的设想进行验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先创建一个字符串，存储着<span class="string">&quot;hello&quot;</span></span><br><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">然后再去创建s2字符串，同样存储着<span class="string">&quot;hello&quot;</span></span><br><span class="line">String s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">我们已经知道，字符串是存储在方法区的字符串常量池</span><br><span class="line"><span class="string">&quot;hello&quot;</span>是存储在方法区的字符串常量池当中</span><br><span class="line">所以这个<span class="string">&quot;hello&quot;</span>不会新建。（因为这个对象已经存在了！）</span><br><span class="line">那么如何去验证呢？</span><br><span class="line">System.out.println(s1 == s2); </span><br><span class="line">已知 == 双等号比较引用的话是变量中保存的内存地址</span><br><span class="line">如果他们都是指向的方法区字符串常量池中的同一个字符串，那么他们保存的内存地址应该是一样的！</span><br><span class="line">也就是说System.out.println(s1 == s2); 应该是<span class="keyword">true</span></span><br><span class="line">事实证明的确如此，所以我们的设想得到了验证</span><br></pre></td></tr></table></figure>
<p>当然，这并不意味着我们去判断字符串是否相等就能用”==”了<br>这样不保险，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过<span class="keyword">new</span>对象的方式去创建两个字符串，都是xyz</span><br><span class="line">String x = <span class="keyword">new</span> String(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">String y = <span class="keyword">new</span> String(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">然后去用<span class="string">&quot;==&quot;</span>比较他们是否相等。</span><br><span class="line">按道理应该是的，因为他们都是xyz</span><br><span class="line">System.out.println(x == y); </span><br><span class="line">然而结果是<span class="keyword">false</span>，因为用<span class="string">&quot;==&quot;</span>比较引用的话是变量中保存的内存地址！</span><br><span class="line">然而x和y是<span class="keyword">new</span>出来的，也就是说他们是指向的堆中的<span class="number">2</span>块不同的地址，然后再堆中的那个对象才是指向的同一块字符串常量池！</span><br></pre></td></tr></table></figure>
<p>如下图解释所示：<br><img src="https://img-blog.csdnimg.cn/20200814083211933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>所以可以看到，”==”不保险。正确的做法是应该调用String类的equals方法。<br>String类已经重写了equals方法，以下的equals方法调用的是String重写之后的equals方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>小tips</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String k = <span class="keyword">new</span> String(<span class="string">&quot;testString&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;testString&quot;</span>这个字符串可以后面加<span class="string">&quot;.&quot;</span>呢？</span><br><span class="line">因为<span class="string">&quot;testString&quot;</span>是一个String字符串对象。只要是对象都能调用方法。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;testString&quot;</span>.equals(k));</span><br><span class="line">建议使用这种方式，因为这个可以避免空指针异常。</span><br><span class="line"></span><br><span class="line">System.out.println(k.equals(<span class="string">&quot;testString&quot;</span>));</span><br><span class="line">存在空指针异常的风险。不建议这样写。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="String类中的构造方法"><a href="#String类中的构造方法" class="headerlink" title="String类中的构造方法"></a>String类中的构造方法</h2><p>先上最终结论：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一个：String s = <span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>);</span><br><span class="line">第二个：String s = <span class="string">&quot;&quot;</span>; 最常用</span><br><span class="line">第三个：String s = <span class="keyword">new</span> String(<span class="keyword">char</span>数组);</span><br><span class="line">第四个：String s = <span class="keyword">new</span> String(<span class="keyword">char</span>数组,起始下标,长度);</span><br><span class="line">第五个：String s = <span class="keyword">new</span> String(<span class="keyword">byte</span>数组);</span><br><span class="line">第六个：String s = <span class="keyword">new</span> String(<span class="keyword">byte</span>数组,起始下标,长度)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="String与byte数组"><a href="#String与byte数组" class="headerlink" title="String与byte数组;"></a>String与byte数组;</h3><p>在这个构造方法中可以传进去一个byte数组，然后通过ASCLL码去解析对应的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里只掌握常用的构造方法。</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line"><span class="number">97</span>是a，<span class="number">98</span>是b，<span class="number">99</span>是c</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(bytes);</span><br><span class="line"></span><br><span class="line">前面说过：输出一个引用的时候，会自动调用toString()方法，默认 Object的话，会自动输出对象的内存地址。</span><br><span class="line">通过输出结果我们得出一个结论：String类已经重写了toString()方法。</span><br><span class="line">输出字符串对象的话，输出的不是对象的内存地址，而是字符串本身。</span><br><span class="line">System.out.println(s2);</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String(字节数组,数组元素下标的起始位置,长度)</span><br><span class="line">将<span class="keyword">byte</span>数组中的一部分转换成字符串。</span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(bytes, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s3);</span><br><span class="line">bc</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="String与Char数组"><a href="#String与Char数组" class="headerlink" title="String与Char数组"></a>String与Char数组</h3><p>在这个构造方法中可以传进去一个char数组，然后将每个字符转换成字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = &#123;<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;中&#x27;</span>,<span class="string">&#x27;国&#x27;</span>,<span class="string">&#x27;人&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">String s4 = <span class="keyword">new</span> String(chars);</span><br><span class="line"></span><br><span class="line">System.out.println(s4);</span><br><span class="line">我是中国人</span><br><span class="line"></span><br><span class="line">将<span class="keyword">char</span>数组的一部分转换成字符串</span><br><span class="line">String s5 = <span class="keyword">new</span> String(chars, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s5);</span><br><span class="line">中国人</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="String类当中常用方法"><a href="#String类当中常用方法" class="headerlink" title="String类当中常用方法"></a>String类当中常用方法</h2><p>在API中可以查看到，String类中有许多的方法可以调用，如下<br><img src="https://img-blog.csdnimg.cn/20200814084655408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>下面来学习一些基础的方法。<br>当然如果记不住也可以去查阅API文档</p>
<p>API链接: <a href="https://www.apiref.com/java11-zh/index.html">JDK11版本</a>.<br>API链接: <a href="https://www.matools.com/api/java8">JDK8版本</a>.</p>
<hr>
<h3 id="1（掌握）-char-charAt-int-index"><a href="#1（掌握）-char-charAt-int-index" class="headerlink" title="1（掌握）.char charAt(int index)"></a>1（掌握）.char charAt(int index)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这个方法是将一个字符串中指定位置的字符提取出来，返回一个<span class="keyword">char</span>类型字符</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&quot;中国人&quot;</span>.charAt(<span class="number">1</span>);</span><br><span class="line"><span class="string">&quot;中国人&quot;</span>是一个字符串String对象。只要是对象就能“点.”</span><br><span class="line"></span><br><span class="line">System.out.println(c);</span><br><span class="line">国</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2（了解）-int-compareTo-String-anotherString"><a href="#2（了解）-int-compareTo-String-anotherString" class="headerlink" title="2（了解）.int compareTo(String anotherString)"></a>2（了解）.int compareTo(String anotherString)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">字符串之间比较大小不能直接使用 &gt; &lt; ，需要使用compareTo方法。</span><br><span class="line">注意，这里是比较大下，而并不是单纯的看是否相等！</span><br><span class="line">如想比较是否相等，仅需调用equals方法即可。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="string">&quot;abc&quot;</span>.compareTo(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="number">0</span>（等于<span class="number">0</span>） 前后一致  <span class="number">10</span> - <span class="number">10</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result2 = <span class="string">&quot;abcd&quot;</span>.compareTo(<span class="string">&quot;abce&quot;</span>);</span><br><span class="line">System.out.println(result2);</span><br><span class="line">-<span class="number">1</span>（小于<span class="number">0</span>） 前小后大 <span class="number">8</span> - <span class="number">9</span> = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result3 = <span class="string">&quot;abce&quot;</span>.compareTo(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">System.out.println(result3);</span><br><span class="line"><span class="number">1</span>（大于<span class="number">0</span>） 前大后小 <span class="number">9</span> - <span class="number">8</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">compareTo方法是按照字典序去比较的，比较到第一个不相同的字符就得出结果。</span><br><span class="line">拿着字符串第一个字母和后面字符串的第一个字母比较。能分胜负就不再比较了。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;xyz&quot;</span>.compareTo(<span class="string">&quot;yxz&quot;</span>));</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3（掌握）-boolean-contains-CharSequence-s"><a href="#3（掌握）-boolean-contains-CharSequence-s" class="headerlink" title="3（掌握）.boolean contains(CharSequence s)"></a>3（掌握）.boolean contains(CharSequence s)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去判断前面的字符串中是否包含后面的子字符串。</span><br><span class="line">然后返回一个<span class="keyword">boolean</span>值，<span class="keyword">true</span>代表包含，<span class="keyword">false</span>代表不包含。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld.java&quot;</span>.contains(<span class="string">&quot;.java&quot;</span>));</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;http://www.baidu.com&quot;</span>.contains(<span class="string">&quot;https://&quot;</span>));</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4（掌握）-boolean-endsWith-String-suffix"><a href="#4（掌握）-boolean-endsWith-String-suffix" class="headerlink" title="4（掌握）. boolean endsWith(String suffix)"></a>4（掌握）. boolean endsWith(String suffix)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去判断当前字符串是否以某个子字符串结尾。</span><br><span class="line">然后返回一个<span class="keyword">boolean</span>值，<span class="keyword">true</span>代表是，<span class="keyword">false</span>代表否。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;.java&quot;</span>));</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;test.txt&quot;</span>.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5（掌握）-boolean-equals-Object-anObject"><a href="#5（掌握）-boolean-equals-Object-anObject" class="headerlink" title="5（掌握）.boolean equals(Object anObject)"></a>5（掌握）.boolean equals(Object anObject)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比较两个字符串必须使用equals方法，不能使用“==”</span><br><span class="line">equals只能看出相等不相等。</span><br><span class="line">compareTo方法可以看出是否相等，并且同时还可以看出谁大谁小。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span>.equals(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6（掌握）-boolean-equalsIgnoreCase-String-anotherString"><a href="#6（掌握）-boolean-equalsIgnoreCase-String-anotherString" class="headerlink" title="6（掌握）.boolean equalsIgnoreCase(String anotherString)"></a>6（掌握）.boolean equalsIgnoreCase(String anotherString)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去判断两个字符串是否相等，并且同时忽略大小写。</span><br><span class="line">然后返回一个<span class="keyword">boolean</span>值，<span class="keyword">true</span>代表是，<span class="keyword">false</span>代表否。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;ABc&quot;</span>.equalsIgnoreCase(<span class="string">&quot;abC&quot;</span>));</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7（掌握）-byte-getBytes"><a href="#7（掌握）-byte-getBytes" class="headerlink" title="7（掌握）.byte[] getBytes()"></a>7（掌握）.byte[] getBytes()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去将字符串对象转换成字节数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">&quot;abcdef&quot;</span>.getBytes();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">	System.out.println(bytes[i]);</span><br><span class="line">&#125;</span><br><span class="line">可以得到结果：</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8（掌握）-int-indexOf-String-str"><a href="#8（掌握）-int-indexOf-String-str" class="headerlink" title="8（掌握）.int indexOf(String str)"></a>8（掌握）.int indexOf(String str)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去判断某个子字符串在当前字符串中第一次出现处的索引（下标）。</span><br><span class="line">从<span class="number">0</span>开始</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;oraclejavac++.netc#phppythonjavaoraclec++&quot;</span>.indexOf(<span class="string">&quot;java&quot;</span>));</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9（掌握）-boolean-isEmpty"><a href="#9（掌握）-boolean-isEmpty" class="headerlink" title="9（掌握）.boolean isEmpty()"></a>9（掌握）.boolean isEmpty()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去判断某个字符串是否为“空字符串”。底层源代码调用的应该是字符串的length()方法。</span><br><span class="line">然后返回一个<span class="keyword">boolean</span>值，<span class="keyword">true</span>代表是，<span class="keyword">false</span>代表否。</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(s.isEmpty());</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">String b = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">System.out.println(s.isEmpty());</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10（掌握）-int-length"><a href="#10（掌握）-int-length" class="headerlink" title="10（掌握）. int length()"></a>10（掌握）. int length()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去判断数组长度是length属性，判断字符串长度是length()方法。</span><br><span class="line"></span><br><span class="line">注意！判断数组长度和判断字符串长度不一样！</span><br><span class="line">判断数组长度是length属性，判断字符串长度是length()方法。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span>.length());</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>.length());</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="11（掌握）-int-lastIndexOf-String-str"><a href="#11（掌握）-int-lastIndexOf-String-str" class="headerlink" title="11（掌握）.int lastIndexOf(String str)"></a>11（掌握）.int lastIndexOf(String str)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去判断某个子字符串在当前字符串中最后一次出现的索引（下标）</span><br><span class="line">从<span class="number">0</span>开始</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;oraclejavac++javac#phpjavapython&quot;</span>.lastIndexOf(<span class="string">&quot;java&quot;</span>));</span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="12（掌握）-String-replace-CharSequence-target-CharSequence-replacement"><a href="#12（掌握）-String-replace-CharSequence-target-CharSequence-replacement" class="headerlink" title="12（掌握）. String replace(CharSequence target, CharSequence replacement)"></a>12（掌握）. String replace(CharSequence target, CharSequence replacement)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是替换字符串，将target所表示的字符串换成replacement代表的字符串。</span><br><span class="line">然后返回新的字符串。</span><br><span class="line"></span><br><span class="line">String的父接口就是：CharSequence</span><br><span class="line"></span><br><span class="line">把 http:<span class="comment">// 换成 https://</span></span><br><span class="line">String newString = <span class="string">&quot;http://www.baidu.com&quot;</span>.replace(<span class="string">&quot;http://&quot;</span>, <span class="string">&quot;https://&quot;</span>);</span><br><span class="line">System.out.println(newString);</span><br><span class="line">https:<span class="comment">//www.baidu.com</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="13（掌握）-String-split-String-regex"><a href="#13（掌握）-String-split-String-regex" class="headerlink" title="13（掌握）.String[] split(String regex)"></a>13（掌握）.String[] split(String regex)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是拆分字符串,然后将每个拆分的字符串存储到一个String[]数组当中。</span><br><span class="line">返回值就是String[]  String数组。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;1980-10-11&quot;</span>以<span class="string">&quot;-&quot;</span>分隔符进行拆分。</span><br><span class="line">String[] ymd = <span class="string">&quot;1980-10-11&quot;</span>.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ymd.length; i++)&#123;</span><br><span class="line">	System.out.println(ymd[i]);</span><br><span class="line">&#125;</span><br><span class="line">输出如下：</span><br><span class="line"><span class="number">1980</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="14（掌握）-boolean-startsWith-String-prefix"><a href="#14（掌握）-boolean-startsWith-String-prefix" class="headerlink" title="14（掌握）.boolean startsWith(String prefix)"></a>14（掌握）.boolean startsWith(String prefix)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去判断某个字符串是否以某个子字符串开始。</span><br><span class="line">然后返回一个<span class="keyword">boolean</span>值，<span class="keyword">true</span>代表是，<span class="keyword">false</span>代表否。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;http://www.baidu.com&quot;</span>.startsWith(<span class="string">&quot;http&quot;</span>));</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="15（掌握）-String-substring-int-beginIndex-参数是起始下标。"><a href="#15（掌握）-String-substring-int-beginIndex-参数是起始下标。" class="headerlink" title="15（掌握）. String substring(int beginIndex) 参数是起始下标。"></a>15（掌握）. String substring(int beginIndex) 参数是起始下标。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是截取字符串，从起始下标开始向后截取完。</span><br><span class="line">然后返回新的字符串。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;http://www.baidu.com&quot;</span>.substring(<span class="number">7</span>));</span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="16（掌握）-String-substring-int-beginIndex-int-endIndex"><a href="#16（掌握）-String-substring-int-beginIndex-int-endIndex" class="headerlink" title="16（掌握）.String substring(int beginIndex, int endIndex)"></a>16（掌握）.String substring(int beginIndex, int endIndex)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是截取字符串，从起始下标开始向后到结束位置（不包括）截取完。</span><br><span class="line">beginIndex起始位置（包括）</span><br><span class="line">endIndex结束位置（不包括）</span><br><span class="line">然后返回新的字符串。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;http://www.baidu.com&quot;</span>.substring(<span class="number">7</span>, <span class="number">10</span>));</span><br><span class="line">www</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="17-掌握-char-toCharArray"><a href="#17-掌握-char-toCharArray" class="headerlink" title="17(掌握) .char[] toCharArray()"></a>17(掌握) .char[] toCharArray()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是将字符串转换成<span class="keyword">char</span>数组。</span><br><span class="line">然后返回一个<span class="keyword">char</span>数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] chars = <span class="string">&quot;我是中国人&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">	System.out.println(chars[i]);</span><br><span class="line">&#125;</span><br><span class="line">输出如下：</span><br><span class="line">我</span><br><span class="line">是</span><br><span class="line">中</span><br><span class="line">国</span><br><span class="line">人</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="18（掌握）-String-toLowerCase"><a href="#18（掌握）-String-toLowerCase" class="headerlink" title="18（掌握）.String toLowerCase()"></a>18（掌握）.String toLowerCase()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是转换为小写。</span><br><span class="line">然后返回新的字符串。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;ABCDefKXyz&quot;</span>.toLowerCase());</span><br><span class="line">abcdefkxyz</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="19（掌握）-String-toUpperCase"><a href="#19（掌握）-String-toUpperCase" class="headerlink" title="19（掌握）.String toUpperCase();"></a>19（掌握）.String toUpperCase();</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是转换为小写。</span><br><span class="line">然后返回新的字符串。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;ABCDefKXyz&quot;</span>.toUpperCase());</span><br><span class="line">ABCDEFKXYZ</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="20（掌握）-String-trim"><a href="#20（掌握）-String-trim" class="headerlink" title="20（掌握）. String trim();"></a>20（掌握）. String trim();</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">该方法是去除字符串前后空白</span><br><span class="line">注意仅仅是字符串前后的空白！中间的无法去除！</span><br><span class="line">然后返回新的字符串。</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;           hello      world             &quot;</span>.trim());</span><br><span class="line">hello      world</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="21（掌握）-String-valueOf（）"><a href="#21（掌握）-String-valueOf（）" class="headerlink" title="21（掌握）. String valueOf（）"></a>21（掌握）. String valueOf（）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String中只有一个方法是静态的，不需要<span class="keyword">new</span>对象</span><br><span class="line">这个方法叫做valueOf</span><br><span class="line">作用：将“非字符串”转换成“字符串”</span><br><span class="line"></span><br><span class="line">String s1 = String.valueOf(<span class="number">123</span>);</span><br><span class="line">s1就是指向的字符串<span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">这个静态的valueOf()方法，参数是一个对象的时候，会自动调用该对象的toString()方法！</span><br><span class="line">String s1 = String.valueOf(<span class="keyword">new</span> Customer());</span><br><span class="line"></span><br><span class="line">如果将Customer类中的toString方法重写，就会得到重写的结果。</span><br><span class="line">不再演示，前面自行查阅。</span><br></pre></td></tr></table></figure>

<p>在此基础上，再去研究JAVA自带的打印方法，println()方法的源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">本质上System.out.println()这个方法在输出任何数据的时候都是先转换成字符串，再输出。</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h1><p>思考：我们在实际的开发中，如果需要进行字符串的频繁拼接，会有什么问题？<br>因为java中的字符串是不可变的，每一次拼接都会产生新字符串。<br>这样会占用大量的方法区内存。造成内存空间的浪费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s += <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">就以上两行代码，就导致在方法区字符串常量池当中创建了<span class="number">3</span>个对象：</span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="string">&quot;abchello&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果以后需要进行大量字符串的拼接操作，建议使用JDK中自带的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.StringBuffer</span><br><span class="line">java.lang.StringBuilder</span><br></pre></td></tr></table></figure>

<h2 id="StringBuffer和StringBuilder的用法"><a href="#StringBuffer和StringBuilder的用法" class="headerlink" title="StringBuffer和StringBuilder的用法"></a>StringBuffer和StringBuilder的用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">StringBuffer是默认给一个容量为<span class="number">16</span>的<span class="keyword">byte</span>[] 数组的。（字符串缓冲区对象）</span><br><span class="line"></span><br><span class="line">当进行拼接字符串时，只需调用append方法即可</span><br><span class="line">stringBuffer.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">append方法底层在进行追加的时候，如果<span class="keyword">byte</span>数组满了，会自动扩容。</span><br><span class="line"></span><br><span class="line">也可以指定初始化容量的StringBuffer对象（字符串缓冲区对象）</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>如何优化StringBuffer的性能？</p>
<ul>
<li>在创建StringBuffer的时候尽可能给定一个初始化容量。</li>
<li>最好减少底层数组的扩容次数。预估计一下，给一个大一些初始化容量。</li>
<li>关键点：给一个合适的初始化容量。可以提高程序的执行效率。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder用法同StringBuffer</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="StringBuffer和StringBuilder的区别"><a href="#StringBuffer和StringBuilder的区别" class="headerlink" title="StringBuffer和StringBuilder的区别"></a>StringBuffer和StringBuilder的区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer中的方法都有：<span class="keyword">synchronized</span>关键字修饰。表示StringBuffer在多线程环境下运行是安全的。</span><br><span class="line">StringBuilder中的方法都没有：<span class="keyword">synchronized</span>关键字修饰，表示StringBuilder在多线程环境下运行是不安全的。</span><br><span class="line"></span><br><span class="line">StringBuffer是线程安全的。</span><br><span class="line">StringBuilder是非线程安全的。</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="小题目"><a href="#小题目" class="headerlink" title="小题目"></a>小题目</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String为什么是不可变的？</span><br><span class="line"></span><br><span class="line">在String源代码中，String类中有一个<span class="keyword">byte</span>[]数组，这个<span class="keyword">byte</span>[]数组采用了<span class="keyword">final</span>修饰。</span><br><span class="line">因为数组一旦创建长度不可变。并且被<span class="keyword">final</span>修饰的引用一旦指向某个对象之后，不可再指向其它对象，所以String是不可变的！</span><br><span class="line"><span class="string">&quot;abc&quot;</span> 无法变成 <span class="string">&quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder/StringBuffer为什么是可变的呢？</span><br><span class="line"></span><br><span class="line">在源代码中，StringBuffer/StringBuilder内部实际上是一个<span class="keyword">byte</span>[]数组，这个<span class="keyword">byte</span>[]数组没有被<span class="keyword">final</span>修饰。</span><br><span class="line">StringBuffer/StringBuilder的初始化容量是<span class="number">16</span>，当存满之后会进行扩容，底层调用了数组拷贝的方法System.arraycopy()。</span><br><span class="line">所以StringBuilder/StringBuffer适合于使用字符串的频繁拼接操作。</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记17-（异常）</title>
    <url>/2020/08/15/java_study_17/</url>
    <content><![CDATA[<p>JAVA学习笔记17-（异常）</p>
<a id="more"></a>



<hr>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常是java中一个非常有用的机制，能够让程序员快速定位问题所在并对其进行修改，也能去提醒使用者所出现的错误等等。</p>
<hr>
<h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">什么是异常，java提供异常处理机制有什么用？</span><br><span class="line">	以下程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常</span><br><span class="line">    java语言是很完善的语言，提供了异常的处理方式，以下程序执行过程中出现了不正常情况，</span><br><span class="line">    java把该异常信息打印输出到控制台，供程序员参考。程序员看到异常信息之后，可以对</span><br><span class="line">    程序进行修改，让程序更加的健壮。</span><br><span class="line"></span><br><span class="line">    什么是异常：程序执行过程中的不正常情况。</span><br><span class="line">    异常的作用：增强程序的健壮性。</span><br></pre></td></tr></table></figure>
<p>例如在下面代码中，我们尝试去用10除以0，会触发一个异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        实际上JVM在执行到此处的时候，会<span class="keyword">new</span>异常对象：<span class="keyword">new</span> ArithmeticException(<span class="string">&quot;/ by zero&quot;</span>);</span><br><span class="line">        并且JVM将<span class="keyword">new</span>的异常对象抛出，打印输出信息到控制台了。</span><br><span class="line">        <span class="keyword">int</span> c = a / b;</span><br><span class="line">        System.out.println(a + <span class="string">&quot;/&quot;</span> + b + <span class="string">&quot;=&quot;</span> + c);</span><br></pre></td></tr></table></figure>
<p>这段代码触发异常后会在控制台输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zeroat com.bjpowernode.javase.exception.ExceptionTest01.main(ExceptionTest01.java:<span class="number">14</span>)</span><br><span class="line">这个信息被我们称为：异常信息。这个信息是JVM打印的。</span><br></pre></td></tr></table></figure>
<p>这样，当程序员观察到异常之后，便可以对代码进行维护了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序执行到此处表示除数一定不是<span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> c = a / b;</span><br><span class="line">System.out.println(a + <span class="string">&quot;/&quot;</span> + b + <span class="string">&quot;=&quot;</span> + c);</span><br></pre></td></tr></table></figure>

<p>java语言中异常是以什么形式存在的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">异常在java中以类的形式存在，每一个异常类都可以创建异常对象。</span><br><span class="line">通过“异常类”实例化“异常对象”</span><br><span class="line">NumberFormatException nfe = <span class="keyword">new</span> NumberFormatException(<span class="string">&quot;数字格式化异常！&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(nfe);</span><br><span class="line">java.lang.NumberFormatException: 数字格式化异常！</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="异常的继承结构"><a href="#异常的继承结构" class="headerlink" title="异常的继承结构"></a>异常的继承结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过翻源代码或者API可以得知，异常的老祖宗也是Object</span><br><span class="line"></span><br><span class="line">往下则是Object下的一个Throwable（可抛出的）</span><br><span class="line"></span><br><span class="line">Throwable下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）</span><br><span class="line"></span><br><span class="line">Exception下有两个分支：</span><br><span class="line">	Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</span><br><span class="line">	RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200815171143275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>该图仅是写出了大体的关系，当然JAVA中存在着很多的异常，具体详询API文档。<br>API链接: <a href="https://www.apiref.com/java11-zh/index.html">JDK11版本</a>.<br>API链接: <a href="https://www.matools.com/api/java8">JDK8版本</a>.</p>
<hr>
<h3 id="编译时异常和运行时异常"><a href="#编译时异常和运行时异常" class="headerlink" title="编译时异常和运行时异常"></a>编译时异常和运行时异常</h3><p>异常在Exception中又有Exception的直接子类和RuntimeException<br>分别为编译时异常和运行时异常。<br><strong>编译时异常和运行时异常，都是发生在运行阶段。</strong> 编译阶段异常是不会发生的，因为异常首先就是要创建异常对象！编译阶段是不会创建对象的！</p>
<pre><code>编译时异常因为什么而得名？
    因为编译时异常必须在编译(编写)阶段预先处理（通过throws或者try catch），如果不处理编译器报错，因此得名。
    所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以new对象。
    因为异常的发生就是new异常对象。</code></pre>
<hr>
<h4 id="编译时异常和运行时异常的区别？"><a href="#编译时异常和运行时异常的区别？" class="headerlink" title="编译时异常和运行时异常的区别？"></a>编译时异常和运行时异常的区别？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">编译时异常一般发生的概率比较高。</span><br><span class="line">对于一些发生概率较高的异常，需要在运行之前对其进行预处理。</span><br><span class="line">（例如你出门前看到要下雨了，带把伞，这就是对发生概率较高的异常的预处理。）</span><br><span class="line"></span><br><span class="line">运行时异常一般发生的概率比较低。</span><br><span class="line">所以一般不需要对其进行预处理，否则会太累</span><br><span class="line">（就像你出门前做好万全准备，防护到头发去预防全部可能出现的危险一样，</span><br><span class="line">但是有些危险很明显是可能性很小的，例如你出门被飞机砸到一样</span><br><span class="line">这些危险可以预防，但没必要。）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译时异常还有其他名字：</p>
<blockquote>
<p>受检异常：CheckedException<br>受控异常</p>
</blockquote>
<p>运行时异常还有其它名字：</p>
<blockquote>
<p>未受检异常：UnCheckedException<br>非受控异常</p>
</blockquote>
</blockquote>
<hr>
<h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><p>在JAVA中对异常有两种处理方式：</p>
<blockquote>
<p>1、通过throws向上抛出异常<br>2、通过try···catch去抓取并处理异常</p>
</blockquote>
<p>关于此有个很形象的描述：<br>A在工作时由于异常操作导致公司亏损<br>他有两种方法去补救：<br>1、上报上级，交给他们解决。<br>2、自己掏腰包补偿亏损，这样只有他自己知道。</p>
<p>当然如果上级上报上级，再上报上报···到最后就是上报到CEO处也无法解决时（throws到main方法还未解决异常），公司就倒闭了（程序停止运行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">编译时异常是必须去处理的，无论通过方式<span class="number">1</span>或者<span class="number">2</span></span><br><span class="line">但是运行时异常可以不用去写代码预处理，出了问题提示了再去处理也可</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Throws向上抛出异常"><a href="#Throws向上抛出异常" class="headerlink" title="Throws向上抛出异常"></a>Throws向上抛出异常</h3><p>处理异常的第一种方式：<br>在方法声明的位置上使用throws关键字抛出，谁调用我这个方法，我就抛给谁。抛给调用者来处理。<br>这种处理异常的态度：上报。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;doSome!!!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">这个代码表示doSome()方法在执行过程中，有可能会出现ClassNotFoundException异常。</span><br><span class="line">在方法声明后面使用<span class="keyword">throws</span>关键字抛出，即可将异常抛给这个方法的调用者。</span><br></pre></td></tr></table></figure>
<p>下面在main方法中调用这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	doSome();</span><br><span class="line">	</span><br><span class="line">	这里要注意！doSome方法抛给你了一个异常，你就得对他处理！</span><br><span class="line">	同样，调用者有两种方式。<span class="keyword">throws</span>或者<span class="keyword">try</span> <span class="keyword">catch</span></span><br><span class="line">	也就是要么继续上报要么尝试解决。</span><br><span class="line">	但是main方法中不要上报！</span><br><span class="line">	main方法上报给了JVM，JVM只有终止程序的执行。</span><br><span class="line">	这与我们异常处理的初衷：增强程序的健壮性相违背。</span><br><span class="line">	我们希望的是在出现异常时能够解决并且不去影响程序的运行。</span><br><span class="line">	所以一般在main方法中就会用<span class="keyword">try</span> <span class="keyword">catch</span>去处理异常！</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		doSome();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		这行话意思是去打印堆错误信息，也就是提醒程序员错误。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。</p>
<hr>
<h3 id="通过try···catch去抓取，处理异常"><a href="#通过try···catch去抓取，处理异常" class="headerlink" title="通过try···catch去抓取，处理异常"></a>通过try···catch去抓取，处理异常</h3><p>处理异常的第二种方式：<br>使用try..catch语句对异常进行捕捉。<br>这个异常不会上报，自己把这个事儿处理了。<br>异常抛到此处为止，不再上抛了。<br>使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">	doSome();</span><br><span class="line">	这里是先尝试去执行的语句</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(异常类型 自变量)&#123;&#125;</span><br><span class="line">这里是当抓取到异常时，注意抓取的异常类型必须是人家抛出的异常类型，</span><br><span class="line">不能人抛出了异常A,你却去<span class="keyword">catch</span>异常B</span><br><span class="line">当然你可以去<span class="keyword">catch</span>这个异常的父类，这是允许的，其实就是多态。</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException e) </span><br><span class="line">&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	这里调用了一个异常处理的方法，下面说。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是：<br>1、try语句块中的某一行出现异常，该行后面的代码不会执行。<br>2、try..catch捕捉异常之后，后续代码可以执行。<br>什么意思呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	doSome();</span><br><span class="line">	</span><br><span class="line">	当执行到doSome() 他抛出了一个异常ClassNotFoundException</span><br><span class="line">	这个时候就会转到<span class="keyword">catch</span>里面了，这下面的语句不会被执行！</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">&quot;123&quot;</span>);这句话不会执行！</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">但是<span class="keyword">catch</span>完之后，这下面的会继续正常执行！这就保证了没影响程序的健壮性！即发生了异常也不影响我们程序的整体运行！</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;456&quot;</span>);这句话会执行！</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="深入try-catch"><a href="#深入try-catch" class="headerlink" title="深入try..catch"></a>深入try..catch</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">catch</span>后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">catch</span>可以写多个。建议<span class="keyword">catch</span>的时候，精确的一个一个处理。这样有利于程序的调试。</span><br><span class="line"><span class="number">3</span>、<span class="keyword">catch</span>写多个的时候，从上到下，必须遵守从小到大。也就是得先子类型的异常，再父类型的异常</span><br><span class="line"><span class="number">4</span>、JDK8之后，<span class="keyword">catch</span>也可以这样写！</span><br><span class="line"><span class="keyword">catch</span>(FileNotFoundException | ArithmeticException | NullPointerException e) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;文件不存在？数学异常？空指针异常？都有可能！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="try-catch中的finally子句"><a href="#try-catch中的finally子句" class="headerlink" title="try..catch中的finally子句"></a>try..catch中的finally子句</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、在<span class="keyword">finally</span>子句中的代码是最后执行的，并且是一定会执行的，即使<span class="keyword">try</span>语句块中的代码出现了异常。</span><br><span class="line"><span class="keyword">finally</span>子句必须和<span class="keyword">try</span>一起出现，不能单独编写。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="keyword">finally</span>语句通常使用在哪些情况下呢？</span><br><span class="line">通常在<span class="keyword">finally</span>语句块中完成资源的释放/关闭。</span><br><span class="line">因为<span class="keyword">finally</span>中的代码比较有保障。</span><br><span class="line">即使<span class="keyword">try</span>语句块中的代码出现异常，<span class="keyword">finally</span>中代码也会正常执行。</span><br></pre></td></tr></table></figure>
<p>具体的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	···</span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">	···</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">放在<span class="keyword">finally</span>语句块中的代码是一定会执行的【再次强调！！！】</span><br><span class="line"><span class="keyword">try</span>和<span class="keyword">finally</span>，没有<span class="keyword">catch</span>可以吗？可以。</span><br><span class="line"><span class="keyword">try</span>不能单独使用。</span><br><span class="line"><span class="keyword">try</span> <span class="keyword">finally</span>可以联合使用。</span><br></pre></td></tr></table></figure>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;try...&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">finally</span>中的语句会执行。能执行到。</span><br><span class="line">	System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上代码的执行顺序：</span><br><span class="line">先执行<span class="keyword">try</span>...</span><br><span class="line">再执行<span class="keyword">finally</span>...</span><br><span class="line">最后执行 <span class="keyword">return</span> （<span class="keyword">return</span>语句只要执行方法必然结束。）</span><br></pre></td></tr></table></figure>
<p>当然也有例外情况（也不算啦）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;try...&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	退出JVM语句：</span><br><span class="line">	System.exit(<span class="number">0</span>);</span><br><span class="line">	退出JVM之后，<span class="keyword">finally</span>语句中的代码就不执行了！</span><br><span class="line">	</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="final-finally-finalize"><a href="#final-finally-finalize" class="headerlink" title="final finally finalize"></a>final finally finalize</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">finally</span> finalize有什么区别？</span><br><span class="line">    <span class="keyword">final</span> 关键字</span><br><span class="line">        <span class="keyword">final</span>修饰的类无法继承</span><br><span class="line">        <span class="keyword">final</span>修饰的方法无法覆盖</span><br><span class="line">        <span class="keyword">final</span>修饰的变量不能重新赋值。</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> 关键字</span><br><span class="line">        和<span class="keyword">try</span>一起联合使用。</span><br><span class="line">        <span class="keyword">finally</span>语句块中的代码是必须执行的。</span><br><span class="line"></span><br><span class="line">    finalize 标识符</span><br><span class="line">        是一个Object类中的方法名。</span><br><span class="line">        这个方法是由垃圾回收器GC负责调用的。</span><br></pre></td></tr></table></figure>
<p>具体见前面的笔记。</p>
<hr>
<h4 id="一个关于try···catch的奇怪题目"><a href="#一个关于try···catch的奇怪题目" class="headerlink" title="一个关于try···catch的奇怪题目"></a>一个关于try···catch的奇怪题目</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先定义这么一个方法m</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后在主方法去调用这个方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = m();</span><br><span class="line">	System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">是不是会觉得打印出<span class="number">101</span>？因为<span class="keyword">finally</span>语句不是无论如何都会执行，且<span class="keyword">return</span>在最后执行吗？</span><br><span class="line">错了！打印答案是<span class="number">100</span>！！！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我  也  傻  了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">已知：</span><br><span class="line">java语法规则（有一些规则是不能破坏的，一旦这么说了，就必须这么做！）：</span><br><span class="line"></span><br><span class="line">java中有一条这样的规则：</span><br><span class="line">方法体中的代码必须遵循自上而下顺序依次逐行执行（亘古不变的语法！）</span><br><span class="line"></span><br><span class="line">java中还有一条语法规则：</span><br><span class="line"><span class="keyword">return</span>语句一旦执行，整个方法必须结束（亘古不变的语法！）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">再回过去看m方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">		这行代码出现在<span class="keyword">int</span> i = <span class="number">100</span>;的下面，所以最终结果必须是返回<span class="number">100</span></span><br><span class="line">		<span class="keyword">return</span>语句还必须保证是最后执行的。一旦执行，整个方法结束。</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也就是说，finall的确也执行了</span><br><span class="line">但是由于<span class="keyword">return</span> i 这句的确就是在人机<span class="keyword">int</span> i = <span class="number">100</span>正下方</span><br><span class="line">所以就返回了<span class="number">100</span>！</span><br><span class="line"></span><br><span class="line">可以通过反编译其<span class="class"><span class="keyword">class</span>文件看到深处：</span></span><br><span class="line"><span class="class">反编译之后的效果</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">static</span> <span class="title">int</span> <span class="title">m</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    i++;的确他进行了<span class="keyword">finally</span>的语句，且在<span class="keyword">return</span>之前执行的</span><br><span class="line">    <span class="keyword">return</span> j;的确他也是按顺序直接返回了<span class="number">100</span></span><br><span class="line">    人家没毛病！</span><br><span class="line">&#125;</span><br><span class="line">所以这样JAVA就做到了不打自己脸（）</span><br><span class="line">就难为我呗</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="异常对象的方法"><a href="#异常对象的方法" class="headerlink" title="异常对象的方法"></a>异常对象的方法</h2><p>在try···catch语句中，我们在catch后括号中生命了个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	doSome();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">	这个e就是</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们自然可以通过他去调用方法！<br>异常对象有两个非常重要的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取异常简单的描述信息：</span><br><span class="line">String msg = exception.getMessage();</span><br><span class="line">System.out.println(msg);</span><br><span class="line"></span><br><span class="line">打印异常追踪的堆栈信息：</span><br><span class="line">exception.printStackTrace();</span><br></pre></td></tr></table></figure>

<p>例如如下用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NullPointerException e = <span class="keyword">new</span> NullPointerException(<span class="string">&quot;空指针异常12345&quot;</span>);</span><br><span class="line"></span><br><span class="line">获取异常简单描述信息：这个信息实际上就是构造方法上面String参数。</span><br><span class="line">String msg = e.getMessage(); </span><br><span class="line">System.out.println(msg);</span><br><span class="line">空指针异常<span class="number">12345</span></span><br><span class="line"></span><br><span class="line">打印异常堆栈信息</span><br><span class="line">java后台打印异常堆栈追踪信息的时候，采用了异步线程的方式打印的。</span><br><span class="line">e.printStackTrace();</span><br><span class="line">java.lang.NullPointerException: 空指针异常<span class="number">12345</span></span><br><span class="line">	at com.bjpowernode.javase.exception.ExceptionTest08.main(ExceptionTest08.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p>这两个方法都能帮助我们去快速的定位到异常所在，然后对其进行修改和维护。</p>
<p>如何查看异常信息呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">异常信息追踪信息，从上往下一行一行看。</span><br><span class="line">但是需要注意的是：SUN写的代码就不用看了(看包名就知道是自己的还是SUN的。)。</span><br><span class="line">主要的问题是出现在自己编写的代码上。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="创建自己的异常对象"><a href="#创建自己的异常对象" class="headerlink" title="创建自己的异常对象"></a>创建自己的异常对象</h2><p>SUN提供的JDK内置的异常肯定是不够的用的。在实际的开发中，有很多业务，这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。那么异常类我们程序员可以自己定义吗？</p>
<p>可以。</p>
<p>语法很简单，参照源代码的异常创建方式即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一步：编写一个类继承Exception或者RuntimeException.</span><br><span class="line">第二步：提供两个构造方法，一个无参数的，一个带有String参数的。</span><br><span class="line"></span><br><span class="line">编译时异常：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行时异常</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="利用自己创建的异常"><a href="#利用自己创建的异常" class="headerlink" title="利用自己创建的异常"></a>利用自己创建的异常</h3><p>在前面的笔记中我们写了一个作业：<br>运用数组去模拟栈结构，并完成压栈和弹栈操作<br>当栈满时再压栈便会触发异常，这个时候我们可以自己定义一个异常并在这个时候抛出异常！从而完成提醒异常的目的！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> MyStackOperationException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index &gt;= elements.length - <span class="number">1</span>)&#123;</span><br><span class="line">		改良之前</span><br><span class="line">		System.out.println(<span class="string">&quot;压栈失败，栈已满！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">		改良之后</span><br><span class="line">        创建异常对象</span><br><span class="line">        MyStackOperationException e = <span class="keyword">new</span> MyStackOperationException(<span class="string">&quot;压栈失败，栈已满！&quot;</span>);</span><br><span class="line">        手动将异常抛出去！</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">        这里捕捉没有意义，自己<span class="keyword">new</span>一个异常，自己捉，没有意义。栈已满这个信息你需要传递出去。</span><br><span class="line"></span><br><span class="line">        合并（手动抛出异常！）</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyStackOperationException(<span class="string">&quot;压栈失败，栈已满！&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        程序能够走到这里，说明栈没满</span><br><span class="line">        向栈中加<span class="number">1</span>个元素，栈帧向上移动一个位置。</span><br><span class="line">        index++;</span><br><span class="line">        elements[index] = obj;</span><br><span class="line">        在声明一次：所有的System.out.println()方法执行时，如果输出引用的话，自动调用引用的toString()方法。</span><br><span class="line">        System.out.println(<span class="string">&quot;压栈&quot;</span> + obj + <span class="string">&quot;元素成功，栈帧指向&quot;</span> + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="方法覆盖与异常"><a href="#方法覆盖与异常" class="headerlink" title="方法覆盖与异常"></a>方法覆盖与异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">之前在讲解方法覆盖的时候，当时遗留了一个问题？</span><br><span class="line">重写之后的方法不能比重写之前的方法抛出更多（更宽泛）的异常，可以更少。</span><br><span class="line">一般来说覆盖直接复制粘贴就可！</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记20-（集合③）</title>
    <url>/2020/08/18/java_study_20/</url>
    <content><![CDATA[<p>JAVA学习笔记20-（集合③）</p>
<a id="more"></a>



<hr>
<h1 id="集合③"><a href="#集合③" class="headerlink" title="集合③"></a>集合③</h1><blockquote>
<p>HashSet &amp;&amp; TreeSet<br>Map<br>哈希表<br>二叉树<br>Collections工具类</p>
</blockquote>
<hr>
<h2 id="HashSet-amp-amp-TreeSet"><a href="#HashSet-amp-amp-TreeSet" class="headerlink" title="HashSet &amp;&amp; TreeSet"></a>HashSet &amp;&amp; TreeSet</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet集合：</span><br><span class="line">    无序不可重复。</span><br><span class="line"></span><br><span class="line">TreeSet集合存储元素特点：</span><br><span class="line">    1、无序不可重复的，但是存储的元素可以自动按照大小顺序排序！称为：可排序集合。</span><br><span class="line">    2、无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map作为一个父接口，其特点如下：</span><br><span class="line">1、Map集合和Collection集合没有关系。</span><br><span class="line">2、Map集合以key和value的方式存储数据：</span><br><span class="line">	键值对key和value都是引用数据类型。</span><br><span class="line">	key和value都是存储对象的内存地址。</span><br><span class="line">	key起到主导的地位，value是key的一个附属品。</span><br><span class="line">3、key和value都是存储java对象的内存地址。</span><br><span class="line">4、所有Map集合的key特点：无序不可重复的。</span><br><span class="line">Map集合的key和Set集合存储元素特点相同。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在Map接口中有许多方法，详情查询API文档。</span><br><span class="line">下面介绍Map中的常用方法：</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span> 向Map集合中添加键值对</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span> 通过key获取value</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>    清空Map集合</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> 判断Map中是否包含某个key</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> 判断Map中是否包含某个value</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>   判断Map集合中元素个数是否为0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span> 通过key删除键值对</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> 获取Map集合中键值对的个数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> 获取Map集合中所有的value，返回一个Collection</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> 获取Map集合所有的key（所有的键是一个set集合）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">将Map集合转换成Set集合</span></span><br><span class="line"><span class="function">假设现在有一个Map集合，如下所示：</span></span><br><span class="line"><span class="function">map1集合对象</span></span><br><span class="line"><span class="function">key             value</span></span><br><span class="line"><span class="function">----------------------------</span></span><br><span class="line"><span class="function">1               zhangsan</span></span><br><span class="line"><span class="function">2               lisi</span></span><br><span class="line"><span class="function">3               wangwu</span></span><br><span class="line"><span class="function">4               zhaoliu</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Set set </span>= map1.entrySet();</span><br><span class="line">set集合对象</span><br><span class="line"><span class="number">1</span>=zhangsan 【注意：Map集合通过entrySet()方法转换成的这个Set集合，Set集合中元素的类型是 Map.Entry&lt;K,V&gt;】</span><br><span class="line"><span class="number">2</span>=lisi     【Map.Entry和String一样，都是一种类型的名字，只不过：Map.Entry是静态内部类，是Map中的静态内部类】</span><br><span class="line"><span class="number">3</span>=wangwu</span><br><span class="line"><span class="number">4</span>=zhaoliu ---&gt; 这个东西是个什么？Map.Entry</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下面是对这些常用方法的代码演示：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        创建Map集合对象</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        向Map集合中添加键值对</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>); <span class="comment">// 1在这里进行了自动装箱。</span></span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        通过key获取value</span><br><span class="line">        String value = map.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        </span><br><span class="line">        获取键值对的数量</span><br><span class="line">        System.out.println(<span class="string">&quot;键值对的数量：&quot;</span> + map.size());</span><br><span class="line">        </span><br><span class="line">        通过key删除key-value</span><br><span class="line">        map.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;键值对的数量：&quot;</span> + map.size());</span><br><span class="line">        </span><br><span class="line">        判断是否包含某个key</span><br><span class="line">        contains方法底层调用的都是equals进行比对的，所以自定义的类型需要重写equals方法。</span><br><span class="line">        System.out.println(map.containsKey(<span class="keyword">new</span> Integer(<span class="number">4</span>))); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">        判断是否包含某个value</span><br><span class="line">        System.out.println(map.containsValue(<span class="keyword">new</span> String(<span class="string">&quot;wangwu&quot;</span>))); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        获取所有的value</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(String s : values)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        清空map集合</span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;键值对的数量：&quot;</span> + map.size());</span><br><span class="line">        </span><br><span class="line">        判断是否为空</span><br><span class="line">        System.out.println(map.isEmpty()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Map集合的遍历【非常重要】"><a href="#Map集合的遍历【非常重要】" class="headerlink" title="Map集合的遍历【非常重要】"></a>Map集合的遍历【非常重要】</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于Map的遍历，有两种思路方法：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、获取所有的key，然后通过key去获得value完成遍历。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span><br><span class="line">这个方法是把Map集合直接全部转换成Set集合。</span><br><span class="line">Set集合中元素的类型是：Map.Entry</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下面是对这两种方法的代码实现：</span><br><span class="line"></span><br><span class="line">首先创建集合：</span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">map.put(<span class="number">4</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">方法<span class="number">1</span>：</span><br><span class="line">获取所有的key，通过遍历key，来遍历value。所有的key是一个Set集合</span><br><span class="line"></span><br><span class="line">先通过keySet()方法取出所有key存储在keys集合中：</span><br><span class="line">Set&lt;Integer&gt; keys = map.keySet();</span><br><span class="line"></span><br><span class="line">迭代器完成遍历：</span><br><span class="line">Iterator&lt;Integer&gt; it = keys.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	取出其中一个key</span><br><span class="line">	Integer key = it.next();</span><br><span class="line">	通过key获取value</span><br><span class="line">	String value = map.get(key);</span><br><span class="line">	System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach也可以完成遍历：</span><br><span class="line"><span class="keyword">for</span>(Integer key : keys)&#123;</span><br><span class="line">	System.out.println(key + <span class="string">&quot;=&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line">这种方式效率比较高，因为获取key和value都是直接从node对象中获取的属性值。</span><br><span class="line">比较适合于大数据量。</span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()通过entrySet()方法去获得：</span><br><span class="line"></span><br><span class="line">首先通过entrySet()方法来转换：</span><br><span class="line">Map.Entry其实是个内部类，是个类名，后面带&lt;&gt;是泛型，set是集合名(变量名)</span><br><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();</span><br><span class="line"></span><br><span class="line">迭代器完成遍历：</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it2 = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">	Map.Entry&lt;Integer,String&gt; node = it2.next();</span><br><span class="line">	Integer key = node.getKey();</span><br><span class="line">	String value = node.getValue();</span><br><span class="line">	System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach完成遍历：</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; node : set)&#123;</span><br><span class="line">	System.out.println(node.getKey() + <span class="string">&quot;---&gt;&quot;</span> + node.getValue());</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="哈希表-散列表-数据结构"><a href="#哈希表-散列表-数据结构" class="headerlink" title="哈希表/散列表 数据结构"></a>哈希表/散列表 数据结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先要知道哪些集合底层是哈希表？</span><br><span class="line">HashMap</span><br><span class="line">HashSet（他的底层是HashMap，进而是哈希表）</span><br><span class="line">HashTable</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">哈希表/散列表是一个怎样的数据结构？</span><br><span class="line">初步理解：</span><br><span class="line"></span><br><span class="line">哈希表是一个将数组和链表结合起来的结构，他结合了他们各自的优点</span><br><span class="line">数组：在查询方面效率很高，随机增删方面效率很低。</span><br><span class="line">单向链表：在随机增删方面效率较高，在查询方面效率很低。</span><br><span class="line">形成了一个新的数据结构。</span><br><span class="line"></span><br><span class="line">HashMap集合底层的源代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span></span>&#123;</span><br><span class="line">	HashMap底层实际上就是一个数组。（一维数组）</span><br><span class="line">	Node&lt;K,V&gt;[] table;</span><br><span class="line">	静态的内部类HashMap.Node</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;  哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储成数组的下标。）</span><br><span class="line">	<span class="keyword">final</span> K key;  存储到Map集合中的那个key</span><br><span class="line">	V value;  存储到Map集合中的那个value</span><br><span class="line">	Node&lt;K,V&gt; next;  下一个节点的内存地址。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">哈希表/散列表：一维数组，这个数组中每一个元素是一个单向链表。（数组和链表的结合体。）</span><br><span class="line"></span><br><span class="line">HashMap集合的key部分特点：</span><br><span class="line">无序，不可重复。</span><br><span class="line">为什么无序？ 因为不一定挂到哪个单向链表上。</span><br><span class="line">不可重复是怎么保证的？ equals方法来保证HashMap集合的key不可重复。如果key重复了，value会覆盖。</span><br><span class="line"></span><br><span class="line">哈希表HashMap使用不当时无法发挥性能！</span><br><span class="line">假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了纯单向链表。这种情况我们成为：散列分布不均匀。</span><br><span class="line">什么是散列分布均匀？</span><br><span class="line">假设有<span class="number">100</span>个元素，<span class="number">10</span>个单向链表，那么每个单向链表上有<span class="number">10</span>个节点，这是最好的，是散列分布均匀的。</span><br><span class="line"></span><br><span class="line">假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗，有什么问题？</span><br><span class="line">	不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。也是散列分布不均匀。</span><br><span class="line"></span><br><span class="line">散列分布均匀需要你重写hashCode()方法时有一定的技巧。</span><br><span class="line"></span><br><span class="line">重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写hashCode和equals方法。</span><br><span class="line"></span><br><span class="line">HashMap集合的默认初始化容量是<span class="number">16</span>，默认加载因子是<span class="number">0.75</span></span><br><span class="line">这个默认加载因子是当HashMap集合底层数组的容量达到<span class="number">75</span>%的时候，数组开始扩容。</span><br><span class="line"></span><br><span class="line">重点，记住：HashMap集合初始化容量必须是<span class="number">2</span>的倍数，这也是官方推荐的，这是因为达到散列均匀，为了提高HashMap集合的存取效率，所必须的。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下面是对于哈希表的图片详解：</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200819212044490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于哈希表，重点要掌握的是：</span><br><span class="line">map.put(k,v)</span><br><span class="line">v = map.get(k)</span><br><span class="line">以上这两个方法的实现原理！</span><br><span class="line"></span><br><span class="line">在上图已经写了这两个方法的原理了。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(k,v)原理：</span><br><span class="line">首先将k,v封装到Node对象当中。</span><br><span class="line">然后底层会调用k的hashCode()方法去得出其哈希值</span><br><span class="line">然后通过哈希函数/哈希算法去将hash值转换为数组的下标</span><br><span class="line">如果下标所指的位置上没有任何元素，就把Node添加到这个位置上</span><br><span class="line">如果此下标对应的位置有链表，就会拿着k去跟链表上每个节点中的k进行equals</span><br><span class="line">如果所有的equals方法都返回<span class="keyword">false</span>（都不相等），则在链表末尾新添这个节点</span><br><span class="line">如果其中有一个equals方法反悔了<span class="keyword">true</span>，那么这个节点的value将被覆盖（不可重复）</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">v = map.get(k)原理：</span><br><span class="line">先调用k的hashCode()方法得出哈希值，然后通过哈希算法转换成数组下标</span><br><span class="line">然后通过数组下标去快速定位到位置</span><br><span class="line">如果这个位置什么也没有，返回<span class="keyword">null</span></span><br><span class="line">如果这个位置有单向链表，那么会拿着参数k和单向链表上的每个节点中的k进行equals</span><br><span class="line">如果所有equals方法返回<span class="keyword">false</span>，那么get方法返回<span class="keyword">null</span></span><br><span class="line">只要其中有一个节点的k和参数k equals的时候返回<span class="keyword">true</span></span><br><span class="line">那么这个节点的value就是我们要找的value，get方法最终返回这个要找的value</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从上面的原理可以看出，如果用哈希表的话，必须去重写两个方法！</span><br><span class="line">放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写hashCode和equals方法！</span><br><span class="line">具体重写使用IDEA工具生成即可</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！</span><br><span class="line">equals方法有可能调用，也有可能不调用。</span><br><span class="line">    拿put(k,v)举例，什么时候equals不会调用？</span><br><span class="line">        k.hashCode()方法返回哈希值，</span><br><span class="line">        哈希值经过哈希算法转换成数组下标。</span><br><span class="line">        数组下标位置上如果是<span class="keyword">null</span>，equals不需要执行。</span><br><span class="line">    拿get(k)举例，什么时候equals不会调用？</span><br><span class="line">        k.hashCode()方法返回哈希值，</span><br><span class="line">        哈希值经过哈希算法转换成数组下标。</span><br><span class="line">        数组下标位置上如果是<span class="keyword">null</span>，equals不需要执行。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、注意：如果一个类的equals方法重写了，那么hashCode()方法必须重写。</span><br><span class="line">并且equals方法返回如果是<span class="keyword">true</span>，hashCode()方法返回的值必须一样。</span><br><span class="line">    equals方法返回<span class="keyword">true</span>表示两个对象相同，在同一个单向链表上比较。</span><br><span class="line">    那么对于同一个单向链表上的节点来说，他们的哈希值都是相同的。</span><br><span class="line">    所以hashCode()方法的返回值也应该相同。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、终极结论：</span><br><span class="line">    放在HashMap集合key部分的，以及放在HashSet集合中的元素，需要同时重写hashCode方法和equals方法。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、对于哈希表数据结构来说：</span><br><span class="line">    如果o1和o2的hash值相同，一定是放到同一个单向链表上。</span><br><span class="line">    当然如果o1和o2的hash值不同，但由于哈希算法执行结束之后转换的数组下标可能相同，此时会发生“哈希碰撞”。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小TIPS：</span><br><span class="line"></span><br><span class="line">HashMap集合key部分允许null吗？</span><br><span class="line">    允许</span><br><span class="line">    但是要注意：HashMap集合的key null值只能有一个。</span><br><span class="line"></span><br><span class="line">Hashtable的key可以为null吗？</span><br><span class="line">    Hashtable的key和value都是不能为null的。</span><br><span class="line">    HashMap集合的key和value都是可以为null的。</span><br><span class="line"></span><br><span class="line">Hashtable方法都带有synchronized：线程安全的。</span><br><span class="line">线程安全有其它的方案，这个Hashtable对线程的处理</span><br><span class="line">导致效率较低，使用较少了。</span><br><span class="line"></span><br><span class="line">Hashtable和HashMap一样，底层都是哈希表数据结构。</span><br><span class="line">Hashtable的初始化容量是11，默认加载因子是：0.75f</span><br><span class="line">Hashtable的扩容是：原容量 * 2 + 1</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">目前只看到了Properties属性类对象的相关方法。</span><br><span class="line">Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。</span><br><span class="line">Properties被称为属性类对象。</span><br><span class="line">Properties是线程安全的。</span><br><span class="line"></span><br><span class="line">创建一个Properties对象</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">需要掌握Properties的两个方法，一个存，一个取。</span><br><span class="line">pro.setProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;</span>);</span><br><span class="line">pro.setProperty(<span class="string">&quot;driver&quot;</span>,<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">pro.setProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">pro.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">通过key获取value</span><br><span class="line">String url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String driver = pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">String username = pro.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">String password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(url);</span><br><span class="line">System.out.println(driver);</span><br><span class="line">System.out.println(username);</span><br><span class="line">System.out.println(password);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二叉树-数据结构"><a href="#二叉树-数据结构" class="headerlink" title="二叉树 数据结构"></a>二叉树 数据结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先要知道哪些集合底层是二叉树？</span><br><span class="line">TreeMap</span><br><span class="line">TreeSet（他的底层是TreeMap，进而是二叉树）</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于二叉树</span><br><span class="line"></span><br><span class="line">初步理解：</span><br><span class="line">（基于TreeSet，因为其实现了SortedSet接口，故可排序，TreeMap同理实现SortedMap接口，可排序）</span><br><span class="line"></span><br><span class="line">TreeSet集合存储元素特点：</span><br><span class="line">    <span class="number">1</span>、无序不可重复的，但是存储的元素可以自动按照大小顺序排序！</span><br><span class="line">    称为：可排序集合。</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>、无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标。</span><br><span class="line">    </span><br><span class="line">TreeSet集合底层实际上是一个TreeMap</span><br><span class="line">TreeMap集合底层是一个二叉树。</span><br><span class="line">放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。</span><br><span class="line">TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。</span><br><span class="line">称为：可排序集合。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面图解释了关于二叉树的数据结构</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/202008192153351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTQ0MzM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于此图的解释：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、TreeSet/TreeMap是自平衡二叉树。遵循左小右大的原则存放。（存放的时候就会进行大小比较）</span><br><span class="line"><span class="number">2</span>、遍历二叉树有三种方式：</span><br><span class="line">	前序遍历：根 左 右</span><br><span class="line">	中序遍历：左 根 右</span><br><span class="line">	后序遍历：左 右 根</span><br><span class="line">	</span><br><span class="line">	前中后说的是 根 的位置。</span><br><span class="line"><span class="number">3</span>、TreeSet集合/TreeMap集合采用的是：中序遍历方式。</span><br><span class="line">Iterator迭代器也是，左 根 右。</span><br><span class="line"></span><br><span class="line">例如将一组数据：</span><br><span class="line"><span class="number">100</span>,<span class="number">200</span>,<span class="number">50</span>，<span class="number">60</span>,<span class="number">80</span>，<span class="number">120</span>,<span class="number">140</span>,<span class="number">130</span>,<span class="number">135</span>,<span class="number">180</span>,<span class="number">666</span>,<span class="number">40</span>,<span class="number">50</span>放入自平衡二叉树</span><br><span class="line">流程如下：</span><br><span class="line">先放<span class="number">100</span>，第一个 根</span><br><span class="line">然后<span class="number">200</span>根<span class="number">100</span>比较，<span class="number">200</span>&gt;<span class="number">100</span>，故放在<span class="number">100</span>的右边</span><br><span class="line">然后再<span class="number">50</span>跟<span class="number">100</span>比较，<span class="number">50</span>&lt;<span class="number">100</span>,故放在<span class="number">100</span>的左边</span><br><span class="line">之后每次都是跟<span class="number">100</span>开始比较，然后循环，直到找到一个自己的空位为止</span><br><span class="line"></span><br><span class="line">由于存放中已经排了序，故取出的时候自动按照了大小顺序排序。</span><br><span class="line">可自行模拟中序遍历，不再赘述，可以看出是自动排序了。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当我们将一些JAVA自带的类型放进TreeSet时，是可以自动排序的。</span><br><span class="line">那如果我们将自定义的类型放入TreeSet，可以自动排序吗？</span><br><span class="line"></span><br><span class="line">下面的代码开始试验：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">32</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">20</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="number">30</span>);</span><br><span class="line">        Person p4 = <span class="keyword">new</span> Person(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        创建TreeSet集合</span><br><span class="line">        TreeSet&lt;Person&gt; persons = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        添加元素</span><br><span class="line">        persons.add(p1);</span><br><span class="line">        persons.add(p2);</span><br><span class="line">        persons.add(p3);</span><br><span class="line">        persons.add(p4);</span><br><span class="line"></span><br><span class="line">        遍历</span><br><span class="line">        <span class="keyword">for</span> (Person p : persons)&#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    重写toString()方法</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person[age=&quot;</span>+age+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">很遗憾的是，不行！</span><br><span class="line">程序运行的时候出现了这个异常：</span><br><span class="line">java.lang.ClassCastException:<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">bjpowernode</span>.<span class="title">javase</span>.<span class="title">collection</span>.<span class="title">Personcannot</span> <span class="title">be</span> <span class="title">cast</span> <span class="title">to</span> <span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span></span></span><br><span class="line"><span class="class">程序中对于<span class="title">Person</span>类型来说，无法排序。因为没有指定<span class="title">Person</span>对象之间的比较规则。</span></span><br><span class="line"><span class="class">谁大谁小并没有说！我们需要给程序一个自定义类的排序规则！</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">如何给一个比较规则？通过翻阅源代码我们可以知道，<span class="title">JAVA</span>自带的类型之所以能够实现排序</span></span><br><span class="line"><span class="class">是因为他们实现了<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>接口。</span></span><br><span class="line"><span class="class">或者在创建对象时通过构造方法传入一个比较器<span class="title">Comparator</span>。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">下面的代码实现了<span class="title">Comparable</span>接口</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TreeSetTest04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer c1 = <span class="keyword">new</span> Customer(<span class="number">32</span>);</span><br><span class="line">        Customer c2 = <span class="keyword">new</span> Customer(<span class="number">20</span>);</span><br><span class="line">        Customer c3 = <span class="keyword">new</span> Customer(<span class="number">30</span>);</span><br><span class="line">        Customer c4 = <span class="keyword">new</span> Customer(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        创建TreeSet集合</span><br><span class="line">        TreeSet&lt;Customer&gt; customers = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        添加元素</span><br><span class="line">        customers.add(c1);</span><br><span class="line">        customers.add(c2);</span><br><span class="line">        customers.add(c3);</span><br><span class="line">        customers.add(c4);</span><br><span class="line"></span><br><span class="line">        遍历</span><br><span class="line">        <span class="keyword">for</span> (Customer c : customers)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">放在TreeSet集合中的元素需要实现java.lang.Comparable接口。</span><br><span class="line">并且实现compareTo方法。equals可以不写。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Customer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    需要在这个方法中编写比较的逻辑，或者说比较的规则，按照什么进行比较！</span><br><span class="line">    拿着参数k和集合中的每一个k进行比较，返回值可能是&gt;<span class="number">0</span> &lt;<span class="number">0</span> =<span class="number">0</span></span><br><span class="line">    比较规则最终还是由程序员指定的：例如按照年龄升序。或者按照年龄降序。</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Customer c)</span> </span>&#123; </span><br><span class="line">    	<span class="comment">// 例如调用方法时写c1.compareTo(c2);</span></span><br><span class="line">        <span class="comment">// this是c1</span></span><br><span class="line">        <span class="comment">// c是c2</span></span><br><span class="line">        <span class="comment">// c1和c2比较的时候，就是this和c比较。</span></span><br><span class="line">        可以这么写</span><br><span class="line">        <span class="keyword">int</span> age1 = <span class="keyword">this</span>.age;</span><br><span class="line">        <span class="keyword">int</span> age2 = c.age;</span><br><span class="line">        <span class="keyword">if</span>(age1 == age2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(age1 &gt; age2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        当然简单的写法是这个</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - c.age;</span><br><span class="line">        or：</span><br><span class="line">        <span class="keyword">return</span> c.age - <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Customer[age=&quot;</span>+age+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet集合中元素可排序的第二种方式：使用比较器的方式。</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">    放到TreeSet或者TreeMap集合key部分的元素要想做到排序,包括两种方式：</span><br><span class="line">        第一种：放在集合中的元素实现java.lang.Comparable接口。</span><br><span class="line">        第二种：在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象。</span><br><span class="line">        </span><br><span class="line">Comparable和Comparator怎么选择呢？</span><br><span class="line">    当比较规则不会发生改变的时候，或者说当比较规则只有<span class="number">1</span>个的时候，建议实现Comparable接口。</span><br><span class="line">    如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。</span><br><span class="line"></span><br><span class="line">    Comparator接口的设计符合OCP原则。</span><br><span class="line"></span><br><span class="line">例如下面的代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        创建TreeSet集合的时候，需要使用这个比较器。</span><br><span class="line">        这样不行，没有通过构造方法传递一个比较器进去。</span><br><span class="line">        TreeSet&lt;WuGui&gt; wuGuis = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        给构造方法传递一个比较器。</span><br><span class="line">        TreeSet&lt;WuGui&gt; wuGuis = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> WuGuiComparator());</span><br><span class="line"></span><br><span class="line">        也可以使用匿名内部类的方式（这个类没有名字。直接<span class="keyword">new</span>接口。）</span><br><span class="line">        TreeSet&lt;WuGui&gt; wuGuis = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;WuGui&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(WuGui o1, WuGui o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> WuGui(<span class="number">1000</span>));</span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> WuGui(<span class="number">800</span>));</span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> WuGui(<span class="number">810</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(WuGui wuGui : wuGuis)&#123;</span><br><span class="line">            System.out.println(wuGui);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">乌龟类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WuGui</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WuGui</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;小乌龟[&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">单独在这里编写一个比较器</span><br><span class="line">比较器实现java.util.Comparator接口。（Comparable是java.lang包下的。Comparator是java.util包下的。）</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WuGuiComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">WuGui</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(WuGui o1, WuGui o2)</span> </span>&#123;</span><br><span class="line">        指定比较规则</span><br><span class="line">        按照年龄排序</span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Collections 集合工具类，方便集合的操作。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、线程安全</span><br><span class="line">ArrayList集合不是线程安全的。</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">将其变成线程安全的</span><br><span class="line">Collections.synchronizedList(list);</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、排序</span><br><span class="line">Collections.sort(list);</span><br><span class="line">注意：对List集合中元素排序，需要保证List集合中的元素实现了：Comparable接口。</span><br><span class="line"></span><br><span class="line">对Set集合怎么排序呢？</span><br><span class="line">将Set集合转换成List集合</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">List&lt;String&gt; myList = <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line"></span><br><span class="line">这种方式也可以排序。（不实现Comparable接口，而是通过比较器）</span><br><span class="line">Collections.sort(list集合, 比较器对象)</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>code_study</tag>
      </tags>
  </entry>
</search>
